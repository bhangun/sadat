package io.quarkus.ai.agent.runtime.schema.storage;

import io.quarkus.ai.agent.runtime.model.*;
import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;
import io.smallrye.mutiny.Uni;
import jakarta.persistence.*;
import org.hibernate.annotations.Type;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.inject.Inject;
import jakarta.enterprise.context.ApplicationScoped;
import org.jboss.logging.Logger;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Schema Version Entity - Store schema versions
 */
@Entity
@Table(name = "schema_versions", indexes = {
    @Index(name = "idx_schema_version", columnList = "schemaVersion"),
    @Index(name = "idx_schema_active", columnList = "isActive")
})
public class SchemaVersionEntity extends PanacheEntityBase {
    
    @Id
    @Column(length = 36)
    public String id;
    
    @Column(nullable = false, length = 50)
    public String schemaVersion; // e.g., "1.0.0"
    
    @Column(columnDefinition = "TEXT", nullable = false)
    public String schemaJson; // Full JSON schema
    
    @Column(nullable = false)
    public Boolean isActive; // Current active schema
    
    @Column(nullable = false)
    public Instant createdAt;
    
    @Column(length = 255)
    public String createdBy;
    
    @Column(length = 2000)
    public String description;
    
    @Column(columnDefinition = "TEXT")
    public String changelog;
    
    @PrePersist
    public void prePersist() {
        if (id == null) {
            id = UUID.randomUUID().toString();
        }
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        if (isActive == null) {
            isActive = false;
        }
    }
}

/**
 * Agent Template Entity - Reusable agent templates
 */
@Entity
@Table(name = "agent_templates", indexes = {
    @Index(name = "idx_template_category", columnList = "category"),
    @Index(name = "idx_template_public", columnList = "isPublic")
})
public class AgentTemplateEntity extends PanacheEntityBase {
    
    @Id
    @Column(length = 36)
    public String id;
    
    @Column(nullable = false, length = 255)
    public String name;
    
    @Column(length = 1000)
    public String description;
    
    @Column(length = 100)
    public String category; // e.g., "customer-support", "data-analysis"
    
    @Column(columnDefinition = "TEXT", nullable = false)
    public String templateJson; // Agent template with variables
    
    @Column(nullable = false)
    public Boolean isPublic; // Public or private template
    
    @Column(length = 255)
    public String createdBy;
    
    @Column(nullable = false)
    public Instant createdAt;
    
    @Column(nullable = false)
    public Instant updatedAt;
    
    @Column
    public Integer usageCount; // Track popularity
    
    @Column(columnDefinition = "TEXT")
    public String previewImage; // Base64 or URL
    
    @Column(columnDefinition = "TEXT")
    public String tags; // Comma-separated tags
    
    @PrePersist
    public void prePersist() {
        if (id == null) {
            id = UUID.randomUUID().toString();
        }
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        updatedAt = Instant.now();
        if (isPublic == null) {
            isPublic = false;
        }
        if (usageCount == null) {
            usageCount = 0;
        }
    }
    
    @PreUpdate
    public void preUpdate() {
        updatedAt = Instant.now();
    }
}

/**
 * Workflow Template Entity
 */
@Entity
@Table(name = "workflow_templates")
public class WorkflowTemplateEntity extends PanacheEntityBase {
    
    @Id
    @Column(length = 36)
    public String id;
    
    @Column(nullable = false, length = 255)
    public String name;
    
    @Column(length = 1000)
    public String description;
    
    @Column(length = 100)
    public String category;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    public String workflowJson;
    
    @Column(nullable = false)
    public Boolean isPublic;
    
    @Column
    public Integer usageCount;
    
    @Column(nullable = false)
    public Instant createdAt;
    
    @Column(nullable = false)
    public Instant updatedAt;
}

/**
 * Node Template Entity - Reusable node configurations
 */
@Entity
@Table(name = "node_templates")
public class NodeTemplateEntity extends PanacheEntityBase {
    
    @Id
    @Column(length = 36)
    public String id;
    
    @Column(nullable = false, length = 50)
    public String nodeType; // llm, tool, condition, etc.
    
    @Column(nullable = false, length = 255)
    public String name;
    
    @Column(length = 1000)
    public String description;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    public String configJson; // Node configuration
    
    @Column
    public Boolean isPublic;
    
    @Column
    public Instant createdAt;
}

/**
 * Schema Version Repository
 */
@ApplicationScoped
public class SchemaVersionRepository {
    
    private static final Logger LOG = Logger.getLogger(SchemaVersionRepository.class);
    
    @Inject
    ObjectMapper objectMapper;
    
    /**
     * Save new schema version
     */
    public Uni<SchemaVersionEntity> saveSchemaVersion(String version, String schemaJson, 
                                                      String description, String changelog) {
        return Uni.createFrom().item(() -> {
            SchemaVersionEntity entity = new SchemaVersionEntity();
            entity.schemaVersion = version;
            entity.schemaJson = schemaJson;
            entity.description = description;
            entity.changelog = changelog;
            entity.isActive = false;
            entity.createdBy = "system";
            return entity;
        })
        .chain(entity -> entity.persistAndFlush())
        .map(v -> (SchemaVersionEntity) v);
    }
    
    /**
     * Set active schema version
     */
    public Uni<Void> setActiveVersion(String version) {
        return SchemaVersionEntity.update("isActive = false")
            .chain(() -> SchemaVersionEntity.update("isActive = true where schemaVersion = ?1", version))
            .replaceWithVoid();
    }
    
    /**
     * Get active schema version
     */
    public Uni<SchemaVersionEntity> getActiveSchema() {
        return SchemaVersionEntity.find("isActive = true")
            .firstResult();
    }
    
    /**
     * Get schema by version
     */
    public Uni<SchemaVersionEntity> getSchemaByVersion(String version) {
        return SchemaVersionEntity.find("schemaVersion", version)
            .firstResult();
    }
    
    /**
     * List all schema versions
     */
    public Uni<List<SchemaVersionEntity>> listAllVersions() {
        return SchemaVersionEntity.findAll()
            .list();
    }
}

/**
 * Template Repository
 */
@ApplicationScoped
public class TemplateRepository {
    
    private static final Logger LOG = Logger.getLogger(TemplateRepository.class);
    
    @Inject
    ObjectMapper objectMapper;
    
    /**
     * Save agent template
     */
    public Uni<AgentTemplateEntity> saveAgentTemplate(AgentTemplateEntity template) {
        return template.persistAndFlush()
            .map(v -> template);
    }
    
    /**
     * Get template by ID
     */
    public Uni<AgentTemplateEntity> getTemplate(String id) {
        return AgentTemplateEntity.findById(id);
    }
    
    /**
     * List public templates
     */
    public Uni<List<AgentTemplateEntity>> listPublicTemplates(String category) {
        if (category != null) {
            return AgentTemplateEntity.find("isPublic = true and category = ?1 order by usageCount desc", category)
                .list();
        }
        return AgentTemplateEntity.find("isPublic = true order by usageCount desc")
            .list();
    }
    
    /**
     * Search templates
     */
    public Uni<List<AgentTemplateEntity>> searchTemplates(String query) {
        return AgentTemplateEntity.find(
            "isPublic = true and (lower(name) like ?1 or lower(description) like ?1 or lower(tags) like ?1)",
            "%" + query.toLowerCase() + "%"
        ).list();
    }
    
    /**
     * Increment usage count
     */
    public Uni<Void> incrementUsage(String templateId) {
        return AgentTemplateEntity.<AgentTemplateEntity>findById(templateId)
            .chain(template -> {
                if (template != null) {
                    template.usageCount++;
                    return template.persistAndFlush();
                }
                return Uni.createFrom().voidItem();
            })
            .replaceWithVoid();
    }
}

/**
 * Advanced Multi-level Cache System
 */
@ApplicationScoped
public class SchemaCache {
    
    private static final Logger LOG = Logger.getLogger(SchemaCache.class);
    
    @Inject
    io.quarkus.redis.datasource.ReactiveRedisDataSource redis;
    
    @Inject
    ObjectMapper objectMapper;
    
    // L1 Cache - In-memory
    private final Map<String, CacheEntry> l1Cache = new ConcurrentHashMap<>();
    private final Map<String, Long> l1AccessTime = new ConcurrentHashMap<>();
    private static final int L1_MAX_SIZE = 100;
    private static final long L1_TTL_MS = 60_000; // 1 minute
    
    // L2 Cache - Redis
    private static final long L2_TTL_SECONDS = 3600; // 1 hour
    
    /**
     * Get from cache (L1 -> L2 -> Database)
     */
    public Uni<AgentDefinition> getAgent(String agentId, 
                                         java.util.function.Supplier<Uni<AgentDefinition>> dbLoader) {
        
        // Try L1 cache first
        CacheEntry l1Entry = l1Cache.get("agent:" + agentId);
        if (l1Entry != null && !l1Entry.isExpired()) {
            LOG.debugf("L1 cache hit: %s", agentId);
            l1AccessTime.put("agent:" + agentId, System.currentTimeMillis());
            return Uni.createFrom().item((AgentDefinition) l1Entry.data);
        }
        
        // Try L2 cache (Redis)
        return redis.value(String.class).get("agent:" + agentId)
            .chain(cached -> {
                if (cached != null) {
                    LOG.debugf("L2 cache hit: %s", agentId);
                    try {
                        AgentDefinition agent = objectMapper.readValue(cached, AgentDefinition.class);
                        // Store in L1
                        putL1("agent:" + agentId, agent);
                        return Uni.createFrom().item(agent);
                    } catch (Exception e) {
                        LOG.warnf("Failed to deserialize cached agent: %s", agentId);
                    }
                }
                
                // Load from database
                LOG.debugf("Cache miss, loading from DB: %s", agentId);
                return dbLoader.get()
                    .invoke(agent -> {
                        if (agent != null) {
                            cacheAgent(agentId, agent);
                        }
                    });
            });
    }
    
    /**
     * Cache agent in both L1 and L2
     */
    public void cacheAgent(String agentId, AgentDefinition agent) {
        // Store in L1
        putL1("agent:" + agentId, agent);
        
        // Store in L2 (Redis) - async
        try {
            String json = objectMapper.writeValueAsString(agent);
            redis.value(String.class).set("agent:" + agentId, json, 
                new io.quarkus.redis.datasource.value.SetArgs().ex(L2_TTL_SECONDS))
                .subscribe().with(
                    v -> LOG.debugf("Cached agent in L2: %s", agentId),
                    error -> LOG.warnf("Failed to cache in L2: %s", error.getMessage())
                );
        } catch (Exception e) {
            LOG.warnf(e, "Failed to serialize agent for cache: %s", agentId);
        }
    }
    
    /**
     * Cache workflow
     */
    public void cacheWorkflow(String workflowId, Workflow workflow) {
        putL1("workflow:" + workflowId, workflow);
        
        try {
            String json = objectMapper.writeValueAsString(workflow);
            redis.value(String.class).set("workflow:" + workflowId, json,
                new io.quarkus.redis.datasource.value.SetArgs().ex(L2_TTL_SECONDS))
                .subscribe().with(
                    v -> LOG.debugf("Cached workflow: %s", workflowId),
                    error -> LOG.warnf("Failed to cache workflow: %s", error.getMessage())
                );
        } catch (Exception e) {
            LOG.warnf(e, "Failed to cache workflow: %s", workflowId);
        }
    }
    
    /**
     * Invalidate cache
     */
    public Uni<Void> invalidateAgent(String agentId) {
        l1Cache.remove("agent:" + agentId);
        l1AccessTime.remove("agent:" + agentId);
        
        return redis.key().del("agent:" + agentId)
            .invoke(count -> LOG.debugf("Invalidated cache for agent: %s", agentId))
            .replaceWithVoid();
    }
    
    /**
     * Invalidate workflow cache
     */
    public Uni<Void> invalidateWorkflow(String workflowId) {
        l1Cache.remove("workflow:" + workflowId);
        return redis.key().del("workflow:" + workflowId).replaceWithVoid();
    }
    
    /**
     * Clear all cache
     */
    public Uni<Void> clearAll() {
        l1Cache.clear();
        l1AccessTime.clear();
        return redis.key().flushdb().replaceWithVoid();
    }
    
    /**
     * Get cache statistics
     */
    public Map<String, Object> getStats() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("l1Size", l1Cache.size());
        stats.put("l1MaxSize", L1_MAX_SIZE);
        stats.put("l1TtlMs", L1_TTL_MS);
        stats.put("l2TtlSeconds", L2_TTL_SECONDS);
        
        // Calculate hit rate (simplified)
        long validEntries = l1Cache.values().stream()
            .filter(e -> !e.isExpired())
            .count();
        stats.put("l1ValidEntries", validEntries);
        
        return stats;
    }
    
    // L1 Cache helpers
    
    private void putL1(String key, Object data) {
        evictL1IfNeeded();
        l1Cache.put(key, new CacheEntry(data, System.currentTimeMillis() + L1_TTL_MS));
        l1AccessTime.put(key, System.currentTimeMillis());
    }
    
    private void evictL1IfNeeded() {
        if (l1Cache.size() >= L1_MAX_SIZE) {
            // LRU eviction
            String lruKey = l1AccessTime.entrySet().stream()
                .min(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);
            
            if (lruKey != null) {
                l1Cache.remove(lruKey);
                l1AccessTime.remove(lruKey);
                LOG.debugf("Evicted from L1: %s", lruKey);
            }
        }
    }
    
    private static class CacheEntry {
        final Object data;
        final long expiresAt;
        
        CacheEntry(Object data, long expiresAt) {
            this.data = data;
            this.expiresAt = expiresAt;
        }
        
        boolean isExpired() {
            return System.currentTimeMillis() > expiresAt;
        }
    }
}

/**
 * Cache-aware Agent Repository
 */
@ApplicationScoped
public class CachedAgentRepository {
    
    private static final Logger LOG = Logger.getLogger(CachedAgentRepository.class);
    
    @Inject
    io.quarkus.ai.agent.runtime.persistence.AgentDefinitionRepository baseRepository;
    
    @Inject
    SchemaCache cache;
    
    /**
     * Find agent with caching
     */
    public Uni<AgentDefinition> findById(String agentId) {
        return cache.getAgent(agentId, () -> baseRepository.findAgentById(agentId));
    }
    
    /**
     * Save agent and update cache
     */
    public Uni<AgentDefinition> save(AgentDefinition agent) {
        return baseRepository.saveAgent(agent)
            .invoke(saved -> cache.cacheAgent(saved.getId(), saved));
    }
    
    /**
     * Update agent and invalidate cache
     */
    public Uni<AgentDefinition> update(AgentDefinition agent) {
        return baseRepository.updateAgent(agent)
            .call(updated -> cache.invalidateAgent(updated.getId()))
            .invoke(updated -> cache.cacheAgent(updated.getId(), updated));
    }
    
    /**
     * Delete agent and invalidate cache
     */
    public Uni<Boolean> delete(String agentId) {
        return cache.invalidateAgent(agentId)
            .chain(() -> baseRepository.deleteAgent(agentId));
    }
}

/**
 * Lazy Loading Manager for Large Workflows
 */
@ApplicationScoped
public class LazyLoadingManager {
    
    private static final Logger LOG = Logger.getLogger(LazyLoadingManager.class);
    
    @Inject
    SchemaCache cache;
    
    @Inject
    ObjectMapper objectMapper;
    
    /**
     * Load workflow with lazy loading for large node counts
     */
    public Uni<WorkflowView> loadWorkflowView(Workflow workflow, int page, int pageSize) {
        int totalNodes = workflow.getNodes() != null ? workflow.getNodes().size() : 0;
        int start = page * pageSize;
        int end = Math.min(start + pageSize, totalNodes);
        
        List<Workflow.Node> pagedNodes = workflow.getNodes() != null ?
            workflow.getNodes().subList(start, end) : List.of();
        
        // Get relevant edges for these nodes
        Set<String> nodeIds = pagedNodes.stream()
            .map(Workflow.Node::getId)
            .collect(java.util.stream.Collectors.toSet());
        
        List<Workflow.Edge> relevantEdges = workflow.getEdges() != null ?
            workflow.getEdges().stream()
                .filter(e -> nodeIds.contains(e.getSource()) || nodeIds.contains(e.getTarget()))
                .collect(java.util.stream.Collectors.toList()) : List.of();
        
        WorkflowView view = new WorkflowView();
        view.setWorkflowId(workflow.getId());
        view.setName(workflow.getName());
        view.setTotalNodes(totalNodes);
        view.setCurrentPage(page);
        view.setPageSize(pageSize);
        view.setNodes(pagedNodes);
        view.setEdges(relevantEdges);
        
        return Uni.createFrom().item(view);
    }
    
    /**
     * Load single node with full details
     */
    public Uni<Workflow.Node> loadNodeDetails(String workflowId, String nodeId) {
        String cacheKey = "node:" + workflowId + ":" + nodeId;
        
        // Try cache first
        return cache.getAgent(cacheKey, () -> {
            // Load from database if not in cache
            // In real implementation, this would query the database
            return Uni.createFrom().nullItem();
        });
    }
    
    public static class WorkflowView {
        private String workflowId;
        private String name;
        private int totalNodes;
        private int currentPage;
        private int pageSize;
        private List<Workflow.Node> nodes;
        private List<Workflow.Edge> edges;
        
        // Getters and Setters
        public String getWorkflowId() { return workflowId; }
        public void setWorkflowId(String workflowId) { this.workflowId = workflowId; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public int getTotalNodes() { return totalNodes; }
        public void setTotalNodes(int totalNodes) { this.totalNodes = totalNodes; }
        
        public int getCurrentPage() { return currentPage; }
        public void setCurrentPage(int currentPage) { this.currentPage = currentPage; }
        
        public int getPageSize() { return pageSize; }
        public void setPageSize(int pageSize) { this.pageSize = pageSize; }
        
        public List<Workflow.Node> getNodes() { return nodes; }
        public void setNodes(List<Workflow.Node> nodes) { this.nodes = nodes; }
        
        public List<Workflow.Edge> getEdges() { return edges; }
        public void setEdges(List<Workflow.Edge> edges) { this.edges = edges; }
    }
}