
    // ========== React Integration Example ==========

    /**
     * React Hook for AI Agent Client
     */
    function useAIAgentClient(baseUrl,apiKey) {
        const[client,setClient]=React.useState(null);const[connected,setConnected]=React.useState(false);const[agent,setAgent]=React.useState(null);

        React.useEffect(()=>{const newClient=new AIAgentClient(baseUrl,apiKey);

        newClient.connect().then(()=>{setConnected(true);setClient(newClient);}).catch(console.error);

        // Listen to agent updates
        newClient.on('agentCreated',(data)=>{setAgent(data.agent);});

        newClient.on('agentUpdated',(data)=>{setAgent(data.agent);});

        newClient.on('disconnected',()=>{setConnected(false);});

        return()=>{newClient.disconnect();};},[baseUrl,apiKey]);

        return{client,connected,agent};
    }

    /**
     * React Component Example
     */
    function AIAgentBuilder() {
        const{client,connected,agent}=useAIAgentClient('ws://localhost:8080','your-api-key');

        const[nodes,setNodes]=React.useState([]);const[edges,setEdges]=React.useState([]);const[executionStatus,setExecutionStatus]=React.useState(null);

        React.useEffect(()=>{if(!client)return;

        // Listen to node events
        client.on('nodeAdded',(data)=>{setNodes(prev=>[...prev,data.node]);});

        client.on('nodeUpdated',(data)=>{setNodes(prev=>prev.map(n=>n.id===data.node.id?data.node:n));});

        client.on('nodeDeleted',(data)=>{setNodes(prev=>prev.filter(n=>n.id!==data.nodeId));});

        // Listen to edge events
        client.on('edgeAdded',(data)=>{setEdges(prev=>[...prev,data.edge]);});

        client.on('edgeDeleted',(data)=>{setEdges(prev=>prev.filter(e=>e.id!==data.edgeId));});

        // Listen to execution events
        client.on('executionStarted',(data)=>{setExecutionStatus({status:'running',id:data.executionId});});

        client.on('executionProgress',(data)=>{setExecutionStatus(prev=>({...prev,progress:data}));});

        client.on('executionCompleted',(data)=>{setExecutionStatus({status:'completed',result:data});});

        },[client]);

        const handleAddNode=(type,position)=>{if(!client||!agent)return;

        const node={id:crypto.randomUUID(),type,name:type.charAt(0).toUpperCase()+type.slice(1),position};

        client.addNode(agent.workflows[0].id,node);};

        const handleExecute=async()=>{if(!client||!agent)return;

        try{const result=await client.executeWorkflow(agent.workflows[0].id,{query:'Test query'});console.log('Execution completed:',result);}catch(error){console.error('Execution failed:',error);}};

        return(<div><h1>AI Agent Builder</h1><div>Status:{connected?'Connected':'Disconnected'}</div>

        {agent&&(<div><h2>{agent.name}</h2><button onClick={()=>handleAddNode('llm',{x:100,y:100})}>Add LLM Node</button><button onClick={handleExecute}>Execute Workflow</button></div>)}

        <div><h3>Nodes({nodes.length})</h3>{nodes.map(node=>(<div key={node.id}>{node.name}</div>))}</div>

        {executionStatus&&(<div><h3>Execution Status</h3><pre>{JSON.stringify(executionStatus,null,2)}</pre></div>)}</div>);
    }

    // ========== Vue Integration Example ==========

    /**
     * Vue Composable for AI Agent Client
     */
    function useAIAgent(baseUrl,apiKey){const client=Vue.ref(null);const connected=Vue.ref(false);const agent=Vue.ref(null);const nodes=Vue.ref([]);const edges=Vue.ref([]);

    Vue.onMounted(async()=>{client.value=new AIAgentClient(baseUrl,apiKey);

    await client.value.connect();connected.value=true;

    // Setup listeners
    client.value.on('agentCreated',(data)=>{agent.value=data.agent;});

    client.value.on('nodeAdded',(data)=>{nodes.value.push(data.node);});

    client.value.on('edgeAdded',(data)=>{edges.value.push(data.edge);});});

    Vue.onUnmounted(()=>{if(client.value){client.value.disconnect();}});

    return{client,connected,agent,nodes,edges};}

    // Export for module usage
    if(typeof module!=='undefined'&&module.exports){module.exports=AIAgentClient;
}











    // ========== Example Usage ==========

    /**
     * Complete example showing real-time agent builder
     */
    async function

    exampleUsage() {
    // Initialize client
    const client = new AIAgentClient('ws://localhost:8080', 'your-api-key');

                            // Connect
                            await client.connect();
                            console.log('Connected!');

    // Listen to events
    client.on('agentCreated', (data) => {
                                console.log('Agent created:', data.agent);
    });

    client.on('nodeAdded', (data) => {
                                console.log('Node added:', data.node);
    });

    client.on('executionProgress', (data) => {
                                console.log('Execution progress:', data);
        // Update UI with progress
    });

                            // Create agent
                            const agent = await client.createAgent({
                                id: crypto.randomUUID(),
                            name: 'My AI Agent',
                            type: 'conversational',
                            status: 'active',
                            llmConfig: {
                                provider: 'openai',
                            model: 'gpt-4',
                            apiKey: 'sk-...',
                            parameters: {
                                temperature: 0.7,
                            maxTokens: 2000
            }
        },
                            workflows: []
    });

                            console.log('Agent created:', agent.id);

                            // Create workflow
                            const workflowId = crypto.randomUUID();
                            client.createWorkflow({
                                id: workflowId,
                            name: 'Simple Workflow',
                            nodes: [],
                            edges: []
    });

                            // Add nodes in real-time
                            client.addNode(workflowId, {
                                id: 'start-1',
                            type: 'start',
                            name: 'Start',
                            position: {x: 100, y: 100 }
    });

                            client.addNode(workflowId, {
                                id: 'llm-1',
                            type: 'llm',
                            name: 'Process Query',
                            position: {x: 300, y: 100 },
                            config: {
                                prompt: 'Answer this question: ${query}'
        }
    });

                            client.addNode(workflowId, {
                                id: 'end-1',
                            type: 'end',
                            name: 'End',
                            position: {x: 500, y: 100 }
    });

                            // Connect nodes with edges
                            client.addEdge(workflowId, {
                                id: 'edge-1',
                            source: 'start-1',
                            target: 'llm-1',
                            type: 'default'
    });

                            client.addEdge(workflowId, {
                                id: 'edge-2',
                            source: 'llm-1',
                            target: 'end-1',
                            type: 'default'
    });

                            // Validate agent
                            const validation = await client.validateAgent();
                            if (validation.valid) {
                                console.log('Agent is valid!');
    } else {
                                console.error('Validation errors:', validation.errors);
    }

                            // Execute workflow
                            const result = await client.executeWorkflow(workflowId, {
                                query: 'What is AI?'
    });

                            console.log('Execution result:', result);





/**
 * AI Agent Runtime WebSocket Client
 * Real-time agent/workflow management and execution
 */
public class AIAgentClient {
    constructor(baseUrl = 'ws://localhost:8080', apiKey = null) {
                                this.baseUrl = baseUrl;
                            this.apiKey = apiKey;
                            this.ws = null;
                            this.sessionId = this.generateSessionId();
                            this.listeners = new Map();
                            this.reconnectAttempts = 0;
                            this.maxReconnectAttempts = 5;
                            this.reconnectDelay = 1000;
    }

    /**
                             * Connect to WebSocket
                             */
                            connect() {
        return new Promise((resolve, reject) => {
            const wsUrl = `${this.baseUrl}/ws/agents/${this.sessionId}`;
                            console.log('Connecting to:', wsUrl);

                            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                                console.log('WebSocket connected');
                            this.reconnectAttempts = 0;
                            resolve();
            };

            this.ws.onmessage = (event) => {
                                this.handleMessage(JSON.parse(event.data));
            };

            this.ws.onerror = (error) => {
                                console.error('WebSocket error:', error);
                            reject(error);
            };

            this.ws.onclose = () => {
                                console.log('WebSocket closed');
                            this.emit('disconnected');
                            this.attemptReconnect();
            };
        });
    }

    /**
                             * Disconnect
                             */
                            disconnect() {
        if (this.ws) {
                                this.ws.close();
                            this.ws = null;
        }
    }

    /**
                             * Send message
                             */
                            send(type, data) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket not connected');
        }

                            const message = {
                                type,
                                data,
                                timestamp: Date.now()
        };

                            this.ws.send(JSON.stringify(message));
    }

                            /**
                             * Handle incoming message
                             */
                            handleMessage(message) {
                                console.log('Received:', message.type, message.data);
                            this.emit(message.type, message.data);
    }

                            /**
                             * Event listener
                             */
                            on(event, callback) {
        if (!this.listeners.has(event)) {
                                this.listeners.set(event, []);
        }
                            this.listeners.get(event).push(callback);
    }

                            /**
                             * Emit event
                             */
                            emit(event, data) {
        if (this.listeners.has(event)) {
                                this.listeners.get(event).forEach(callback => callback(data));
        }
    }

    /**
                             * Reconnect logic
                             */
                            attemptReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                                console.error('Max reconnect attempts reached');
                            return;
        }

                            this.reconnectAttempts++;
                            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

                            console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);

        setTimeout(() => {
                                this.connect().catch(console.error);
        }, delay);
    }

    /**
                             * Generate unique session ID
                             */
                            generateSessionId() {
        return 'session-' + Math.random().toString(36).substring(2, 15);
    }

    // ========== Agent Management ==========

    /**
                             * Create agent
                             */
                            async createAgent(agentData) {
                                this.send('createAgent', agentData);

        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Timeout')), 30000);

            this.on('agentCreated', (data) => {
                                clearTimeout(timeout);
                            resolve(data.agent);
            });

            this.on('error', (error) => {
                                clearTimeout(timeout);
                            reject(new Error(error.error));
            });
        });
    }

                            /**
                             * Update agent
                             */
                            updateAgent(agentId, updates) {
                                this.send('updateAgent', { agentId, ...updates });
    }

                            /**
                             * Delete agent
                             */
                            deleteAgent(agentId) {
                                this.send('deleteAgent', { agentId });
    }

    /**
                             * Get agent
                             */
                            async getAgent(agentId) {
                                this.send('getAgent', { agentId });

        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);

            this.on('agentLoaded', (data) => {
                                clearTimeout(timeout);
                            resolve(data.agent);
            });
        });
    }

    /**
     * Validate agent
     */
    async validateAgent() {
        this.send('validateAgent',{});

        return new Promise((resolve)=>{this.on('validationResult',(data)=>{resolve(data);});});
    }

    // ========== Workflow Management ==========

    /**
                             * Create workflow
                             */
                            createWorkflow(workflow) {
                                this.send('createWorkflow', { workflow });
    }

                            /**
                             * Update workflow
                             */
                            updateWorkflow(workflowId, updates) {
                                this.send('updateWorkflow', { workflowId, ...updates });
    }

                            // ========== Node Management ==========

                            /**
                             * Add node
                             */
                            addNode(workflowId, node) {
                                this.send('addNode', { workflowId, node });
    }

                            /**
                             * Update node
                             */
                            updateNode(workflowId, nodeId, updates) {
                                this.send('updateNode', { workflowId, nodeId, ...updates });
    }

                            /**
                             * Delete node
                             */
                            deleteNode(workflowId, nodeId) {
                                this.send('deleteNode', { workflowId, nodeId });
    }

                            /**
                             * Move node (update position)
                             */
                            moveNode(workflowId, nodeId, x, y) {
                                this.send('updateNode', {
                                    workflowId,
                                    nodeId,
                                    position: { x, y }
                                });
    }

                            // ========== Edge Management ==========

                            /**
                             * Add edge
                             */
                            addEdge(workflowId, edge) {
                                this.send('addEdge', { workflowId, edge });
    }

                            /**
                             * Delete edge
                             */
                            deleteEdge(workflowId, edgeId) {
                                this.send('deleteEdge', { workflowId, edgeId });
    }

    // ========== Execution ==========

    /**
                             * Execute workflow
                             */
                            async executeWorkflow(workflowId, input) {
                                this.send('executeWorkflow', { workflowId, input });

        return new Promise((resolve, reject) => {
                                let executionId = null;

            this.on('executionStarted', (data) => {
                                executionId = data.executionId;
                            console.log('Execution started:', executionId);
            });

            this.on('executionProgress', (data) => {
                                console.log('Progress:', data);
            });

            this.on('executionCompleted', (data) => {
                if (data.executionId === executionId) {
                                resolve(data);
                }
            });

            this.on('executionFailed', (data) => {
                if (data.executionId === executionId) {
                                reject(new Error(data.error));
                }
            });
        });
    }

                            /**
                             * Subscribe to execution updates
                             */
                            subscribeExecution(executionId) {
                                this.send('subscribeExecution', { executionId });
    }
}
