package io.quarkus.ai.agent.runtime.schema;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.schema.*;
import io.quarkus.ai.agent.runtime.model.*;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Schema Processor - Validates and processes agent definitions against JSON schema
 */
@ApplicationScoped
public class SchemaProcessor {

    private static final Logger LOG = Logger.getLogger(SchemaProcessor.class);

    @Inject
    ObjectMapper objectMapper;

    private JsonSchema jsonSchema;
    private JsonNode schemaNode;

    @jakarta.annotation.PostConstruct
    void init() {
        try {
            // Load the schema from resources or configuration
            InputStream schemaStream = getClass().getResourceAsStream("/schema/agent-schema.json");
            if (schemaStream == null) {
                LOG.warn("Schema file not found, using default validation");
                return;
            }

            schemaNode = objectMapper.readTree(schemaStream);
            
            JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);
            jsonSchema = factory.getSchema(schemaNode);
            
            LOG.info("Schema loaded successfully");
        } catch (Exception e) {
            LOG.error("Failed to load schema", e);
        }
    }

    /**
     * Validate agent definition against schema
     */
    public Uni<ValidationResult> validateAgentDefinition(String jsonContent) {
        return Uni.createFrom().item(() -> {
            try {
                JsonNode agentNode = objectMapper.readTree(jsonContent);
                
                if (jsonSchema != null) {
                    Set<ValidationMessage> errors = jsonSchema.validate(agentNode);
                    
                    if (!errors.isEmpty()) {
                        List<String> errorMessages = errors.stream()
                            .map(ValidationMessage::getMessage)
                            .collect(Collectors.toList());
                        
                        return new ValidationResult(false, errorMessages);
                    }
                }
                
                // Additional custom validation
                List<String> customErrors = performCustomValidation(agentNode);
                
                if (!customErrors.isEmpty()) {
                    return new ValidationResult(false, customErrors);
                }
                
                return new ValidationResult(true, List.of());
                
            } catch (Exception e) {
                LOG.errorf(e, "Validation failed");
                return new ValidationResult(false, List.of("Invalid JSON: " + e.getMessage()));
            }
        });
    }

    /**
     * Parse and convert JSON to AgentDefinition
     */
    public Uni<AgentDefinition> parseAgentDefinition(String jsonContent) {
        return validateAgentDefinition(jsonContent)
            .chain(validation -> {
                if (!validation.isValid()) {
                    return Uni.createFrom().failure(
                        new IllegalArgumentException("Schema validation failed: " + 
                            String.join(", ", validation.getErrors()))
                    );
                }

                try {
                    JsonNode root = objectMapper.readTree(jsonContent);
                    
                    // Handle both single agent and project format
                    JsonNode agentNode = root.has("agents") ? 
                        root.get("agents").get(0) : root;
                    
                    AgentDefinition agent = objectMapper.treeToValue(agentNode, AgentDefinition.class);
                    
                    return Uni.createFrom().item(agent);
                    
                } catch (Exception e) {
                    LOG.errorf(e, "Failed to parse agent definition");
                    return Uni.createFrom().failure(
                        new IllegalArgumentException("Failed to parse: " + e.getMessage())
                    );
                }
            });
    }

    /**
     * Convert AgentDefinition to JSON
     */
    public Uni<String> serializeAgentDefinition(AgentDefinition agent) {
        return Uni.createFrom().item(() -> {
            try {
                return objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(agent);
            } catch (Exception e) {
                throw new RuntimeException("Failed to serialize agent", e);
            }
        });
    }

    /**
     * Create project wrapper with multiple agents
     */
    public Uni<String> createProjectJson(List<AgentDefinition> agents, ProjectMetadata metadata) {
        return Uni.createFrom().item(() -> {
            try {
                Map<String, Object> project = new HashMap<>();
                
                // Project metadata
                Map<String, Object> projectInfo = new HashMap<>();
                projectInfo.put("id", metadata.getId());
                projectInfo.put("name", metadata.getName());
                projectInfo.put("description", metadata.getDescription());
                
                Map<String, Object> projectMetadata = new HashMap<>();
                projectMetadata.put("createdAt", metadata.getCreatedAt());
                projectMetadata.put("updatedAt", metadata.getUpdatedAt());
                projectMetadata.put("version", metadata.getVersion());
                projectInfo.put("metadata", projectMetadata);
                
                project.put("project", projectInfo);
                project.put("agents", agents);
                
                // Shared resources
                project.put("sharedResources", extractSharedResources(agents));
                
                // Config
                Map<String, Object> config = new HashMap<>();
                config.put("version", "1.0.0");
                config.put("schemaVersion", "1.0.0");
                project.put("config", config);
                
                return objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(project);
                    
            } catch (Exception e) {
                throw new RuntimeException("Failed to create project JSON", e);
            }
        });
    }

    /**
     * Custom validation rules
     */
    private List<String> performCustomValidation(JsonNode agentNode) {
        List<String> errors = new ArrayList<>();

        // Validate workflows
        if (agentNode.has("workflows")) {
            JsonNode workflows = agentNode.get("workflows");
            for (JsonNode workflow : workflows) {
                errors.addAll(validateWorkflow(workflow));
            }
        }

        // Validate LLM config
        if (agentNode.has("llmConfig")) {
            errors.addAll(validateLLMConfig(agentNode.get("llmConfig")));
        }

        // Validate tools
        if (agentNode.has("tools")) {
            JsonNode tools = agentNode.get("tools");
            for (JsonNode tool : tools) {
                errors.addAll(validateTool(tool));
            }
        }

        return errors;
    }

    private List<String> validateWorkflow(JsonNode workflow) {
        List<String> errors = new ArrayList<>();

        if (!workflow.has("nodes") || workflow.get("nodes").size() == 0) {
            errors.add("Workflow must have at least one node");
            return errors;
        }

        // Check for start node
        boolean hasStart = false;
        JsonNode nodes = workflow.get("nodes");
        for (JsonNode node : nodes) {
            if ("start".equals(node.get("type").asText())) {
                hasStart = true;
                break;
            }
        }

        if (!hasStart) {
            errors.add("Workflow must have a START node");
        }

        // Validate edges reference valid nodes
        if (workflow.has("edges")) {
            Set<String> nodeIds = new HashSet<>();
            for (JsonNode node : nodes) {
                nodeIds.add(node.get("id").asText());
            }

            JsonNode edges = workflow.get("edges");
            for (JsonNode edge : edges) {
                String source = edge.get("source").asText();
                String target = edge.get("target").asText();

                if (!nodeIds.contains(source)) {
                    errors.add("Edge references non-existent source node: " + source);
                }
                if (!nodeIds.contains(target)) {
                    errors.add("Edge references non-existent target node: " + target);
                }
            }
        }

        return errors;
    }

    private List<String> validateLLMConfig(JsonNode llmConfig) {
        List<String> errors = new ArrayList<>();

        if (!llmConfig.has("provider")) {
            errors.add("LLM config must have a provider");
        }

        if (!llmConfig.has("model")) {
            errors.add("LLM config must have a model");
        }

        // Validate temperature range
        if (llmConfig.has("parameters") && 
            llmConfig.get("parameters").has("temperature")) {
            double temp = llmConfig.get("parameters").get("temperature").asDouble();
            if (temp < 0 || temp > 2) {
                errors.add("Temperature must be between 0 and 2");
            }
        }

        return errors;
    }

    private List<String> validateTool(JsonNode tool) {
        List<String> errors = new ArrayList<>();

        if (!tool.has("name")) {
            errors.add("Tool must have a name");
        }

        if (!tool.has("type")) {
            errors.add("Tool must have a type");
        }

        if (tool.has("config") && tool.get("config").has("endpoint")) {
            String endpoint = tool.get("config").get("endpoint").asText();
            if (!endpoint.startsWith("http://") && !endpoint.startsWith("https://")) {
                errors.add("Tool endpoint must be a valid HTTP(S) URL");
            }
        }

        return errors;
    }

    private Map<String, Object> extractSharedResources(List<AgentDefinition> agents) {
        Map<String, Object> shared = new HashMap<>();
        
        // Extract common LLM configs
        List<LLMConfig> llmConfigs = agents.stream()
            .map(AgentDefinition::getLlmConfig)
            .filter(Objects::nonNull)
            .distinct()
            .collect(Collectors.toList());
        
        shared.put("llmConfigs", llmConfigs);
        
        // Extract common tools
        List<Tool> tools = agents.stream()
            .filter(a -> a.getTools() != null)
            .flatMap(a -> a.getTools().stream())
            .distinct()
            .collect(Collectors.toList());
        
        shared.put("tools", tools);
        
        return shared;
    }

    public static class ValidationResult {
        private final boolean valid;
        private final List<String> errors;

        public ValidationResult(boolean valid, List<String> errors) {
            this.valid = valid;
            this.errors = errors;
        }

        public boolean isValid() { return valid; }
        public List<String> getErrors() { return errors; }
    }

    public static class ProjectMetadata {
        private String id;
        private String name;
        private String description;
        private String createdAt;
        private String updatedAt;
        private String version;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
        
        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
        
        public String getVersion() { return version; }
        public void setVersion(String version) { this.version = version; }
    }
}

/**
 * Workflow Builder - Build workflows programmatically
 */
@ApplicationScoped
public class WorkflowBuilder {

    private static final Logger LOG = Logger.getLogger(WorkflowBuilder.class);

    private String id;
    private String name;
    private String description;
    private List<Workflow.Node> nodes = new ArrayList<>();
    private List<Workflow.Edge> edges = new ArrayList<>();
    private List<Variable> variables = new ArrayList<>();
    private List<Workflow.Trigger> triggers = new ArrayList<>();

    public WorkflowBuilder() {
        this.id = UUID.randomUUID().toString();
    }

    public WorkflowBuilder withId(String id) {
        this.id = id;
        return this;
    }

    public WorkflowBuilder withName(String name) {
        this.name = name;
        return this;
    }

    public WorkflowBuilder withDescription(String description) {
        this.description = description;
        return this;
    }

    public WorkflowBuilder addNode(Workflow.Node node) {
        this.nodes.add(node);
        return this;
    }

    public WorkflowBuilder addEdge(Workflow.Edge edge) {
        this.edges.add(edge);
        return this;
    }

    public WorkflowBuilder addVariable(Variable variable) {
        this.variables.add(variable);
        return this;
    }

    public WorkflowBuilder addTrigger(Workflow.Trigger trigger) {
        this.triggers.add(trigger);
        return this;
    }

    /**
     * Create a simple linear workflow
     */
    public WorkflowBuilder createLinearWorkflow(List<NodeConfig> nodeConfigs) {
        int x = 100;
        Workflow.Node previousNode = null;

        for (int i = 0; i < nodeConfigs.size(); i++) {
            NodeConfig config = nodeConfigs.get(i);
            
            Workflow.Node node = new Workflow.Node();
            node.setId("node-" + i);
            node.setType(config.type);
            node.setName(config.name);
            
            Workflow.Node.Position pos = new Workflow.Node.Position();
            pos.setX((double) x);
            pos.setY(100.0);
            node.setPosition(pos);
            
            if (config.nodeConfig != null) {
                node.setConfig(config.nodeConfig);
            }
            
            nodes.add(node);

            // Connect to previous node
            if (previousNode != null) {
                Workflow.Edge edge = new Workflow.Edge();
                edge.setId("edge-" + (i - 1));
                edge.setSource(previousNode.getId());
                edge.setTarget(node.getId());
                edge.setType(Workflow.Edge.EdgeType.DEFAULT);
                edges.add(edge);
            }

            previousNode = node;
            x += 200;
        }

        return this;
    }

    /**
     * Add conditional branching
     */
    public WorkflowBuilder addConditionalBranch(String fromNodeId, 
                                               String trueNodeId, 
                                               String falseNodeId,
                                               String condition) {
        // Add condition node
        Workflow.Node condNode = new Workflow.Node();
        condNode.setId("cond-" + UUID.randomUUID().toString().substring(0, 8));
        condNode.setType(Workflow.Node.NodeType.CONDITION);
        condNode.setName("Branch");
        
        Workflow.Node.NodeConfig config = new Workflow.Node.NodeConfig();
        Workflow.Node.NodeConfig.Condition cond = new Workflow.Node.NodeConfig.Condition();
        cond.setExpression(condition);
        config.setCondition(cond);
        condNode.setConfig(config);
        
        nodes.add(condNode);

        // Add edges
        Workflow.Edge toCondition = new Workflow.Edge();
        toCondition.setId("edge-to-cond-" + condNode.getId());
        toCondition.setSource(fromNodeId);
        toCondition.setTarget(condNode.getId());
        edges.add(toCondition);

        Workflow.Edge trueEdge = new Workflow.Edge();
        trueEdge.setId("edge-true-" + condNode.getId());
        trueEdge.setSource(condNode.getId());
        trueEdge.setTarget(trueNodeId);
        trueEdge.setType(Workflow.Edge.EdgeType.CONDITIONAL);
        trueEdge.setLabel("True");
        edges.add(trueEdge);

        Workflow.Edge falseEdge = new Workflow.Edge();
        falseEdge.setId("edge-false-" + condNode.getId());
        falseEdge.setSource(condNode.getId());
        falseEdge.setTarget(falseNodeId);
        falseEdge.setType(Workflow.Edge.EdgeType.CONDITIONAL);
        falseEdge.setLabel("False");
        edges.add(falseEdge);

        return this;
    }

    /**
     * Add parallel execution
     */
    public WorkflowBuilder addParallelExecution(String fromNodeId, 
                                               List<String> parallelNodeIds,
                                               String mergeNodeId) {
        // Add parallel node
        Workflow.Node parallelNode = new Workflow.Node();
        parallelNode.setId("parallel-" + UUID.randomUUID().toString().substring(0, 8));
        parallelNode.setType(Workflow.Node.NodeType.PARALLEL);
        parallelNode.setName("Parallel");
        nodes.add(parallelNode);

        // Connect from node to parallel
        Workflow.Edge toParallel = new Workflow.Edge();
        toParallel.setId("edge-to-parallel");
        toParallel.setSource(fromNodeId);
        toParallel.setTarget(parallelNode.getId());
        edges.add(toParallel);

        // Connect parallel to all branches
        for (String nodeId : parallelNodeIds) {
            Workflow.Edge branch = new Workflow.Edge();
            branch.setId("edge-parallel-" + nodeId);
            branch.setSource(parallelNode.getId());
            branch.setTarget(nodeId);
            edges.add(branch);

            // Connect branch to merge
            Workflow.Edge toMerge = new Workflow.Edge();
            toMerge.setId("edge-merge-" + nodeId);
            toMerge.setSource(nodeId);
            toMerge.setTarget(mergeNodeId);
            edges.add(toMerge);
        }

        return this;
    }

    public Workflow build() {
        Workflow workflow = new Workflow();
        workflow.setId(id);
        workflow.setName(name);
        workflow.setDescription(description);
        workflow.setNodes(nodes);
        workflow.setEdges(edges);
        workflow.setVariables(variables);
        workflow.setTriggers(triggers);

        AgentDefinition.Metadata metadata = new AgentDefinition.Metadata();
        metadata.setCreatedAt(java.time.Instant.now());
        metadata.setUpdatedAt(java.time.Instant.now());
        workflow.setMetadata(metadata);

        return workflow;
    }

    public static class NodeConfig {
        Workflow.Node.NodeType type;
        String name;
        Workflow.Node.NodeConfig nodeConfig;

        public NodeConfig(Workflow.Node.NodeType type, String name) {
            this.type = type;
            this.name = name;
        }

        public NodeConfig withConfig(Workflow.Node.NodeConfig config) {
            this.nodeConfig = config;
            return this;
        }
    }
}

/**
 * Agent Builder - Build agents programmatically
 */
@ApplicationScoped
public class AgentBuilder {

    private static final Logger LOG = Logger.getLogger(AgentBuilder.class);

    private String id;
    private String name;
    private String description;
    private AgentDefinition.AgentType type;
    private AgentDefinition.AgentStatus status;
    private LLMConfig llmConfig;
    private MemoryConfig memoryConfig;
    private List<Tool> tools = new ArrayList<>();
    private List<Workflow> workflows = new ArrayList<>();
    private AgentDefinition.Personality personality;
    private AgentDefinition.Capabilities capabilities;
    private AgentDefinition.Safety safety;

    public AgentBuilder() {
        this.id = UUID.randomUUID().toString();
        this.type = AgentDefinition.AgentType.CONVERSATIONAL;
        this.status = AgentDefinition.AgentStatus.ACTIVE;
    }

    public AgentBuilder withId(String id) {
        this.id = id;
        return this;
    }

    public AgentBuilder withName(String name) {
        this.name = name;
        return this;
    }

    public AgentBuilder withDescription(String description) {
        this.description = description;
        return this;
    }

    public AgentBuilder withType(AgentDefinition.AgentType type) {
        this.type = type;
        return this;
    }

    public AgentBuilder withStatus(AgentDefinition.AgentStatus status) {
        this.status = status;
        return this;
    }

    public AgentBuilder withLLMConfig(LLMConfig llmConfig) {
        this.llmConfig = llmConfig;
        return this;
    }

    public AgentBuilder withMemoryConfig(MemoryConfig memoryConfig) {
        this.memoryConfig = memoryConfig;
        return this;
    }

    public AgentBuilder addTool(Tool tool) {
        this.tools.add(tool);
        return this;
    }

    public AgentBuilder addWorkflow(Workflow workflow) {
        this.workflows.add(workflow);
        return this;
    }

    public AgentBuilder withPersonality(AgentDefinition.Personality personality) {
        this.personality = personality;
        return this;
    }

    public AgentBuilder withCapabilities(AgentDefinition.Capabilities capabilities) {
        this.capabilities = capabilities;
        return this;
    }

    public AgentBuilder withSafety(AgentDefinition.Safety safety) {
        this.safety = safety;
        return this;
    }

    /**
     * Quick setup with defaults
     */
    public AgentBuilder withDefaults(String name, String provider, String model) {
        this.name = name;
        
        // Default LLM config
        LLMConfig llm = new LLMConfig();
        llm.setProvider(LLMConfig.Provider.valueOf(provider.toUpperCase()));
        llm.setModel(model);
        
        LLMConfig.Parameters params = new LLMConfig.Parameters();
        params.setTemperature(0.7);
        params.setMaxTokens(2000);
        llm.setParameters(params);
        
        this.llmConfig = llm;

        // Default memory
        MemoryConfig mem = new MemoryConfig();
        mem.setType(MemoryConfig.MemoryType.BUFFER);
        mem.setStorageBackend(MemoryConfig.StorageBackend.IN_MEMORY);
        this.memoryConfig = mem;

        // Default personality
        AgentDefinition.Personality pers = new AgentDefinition.Personality();
        pers.setTone(AgentDefinition.Personality.Tone.PROFESSIONAL);
        this.personality = pers;

        return this;
    }

    public AgentDefinition build() {
        AgentDefinition agent = new AgentDefinition();
        agent.setId(id);
        agent.setName(name);
        agent.setDescription(description);
        agent.setType(type);
        agent.setStatus(status);
        agent.setLlmConfig(llmConfig);
        agent.setMemoryConfig(memoryConfig);
        agent.setTools(tools);
        agent.setWorkflows(workflows);
        agent.setPersonality(personality);
        agent.setCapabilities(capabilities);
        agent.setSafety(safety);

        AgentDefinition.Metadata metadata = new AgentDefinition.Metadata();
        metadata.setCreatedAt(java.time.Instant.now());
        metadata.setUpdatedAt(java.time.Instant.now());
        metadata.setVersion("1.0.0");
        agent.setMetadata(metadata);

        return agent;
    }
}