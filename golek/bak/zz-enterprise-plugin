// Package enterprise provides production-ready enterprise plugins
package enterprise

import (
	"context"
	"crypto/tls"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/sdk/trace"
	"go.uber.org/zap"
	"golang.org/x/time/rate"

	"tech.kayys.golek/pkg/core"
	"tech.kayys.golek/pkg/plugins"
)

// ============================================================================
// ADVANCED SECURITY PLUGIN
// ============================================================================

// AdvancedSecurityPlugin provides enterprise-grade security features
type AdvancedSecurityPlugin struct {
	*plugins.BasePlugin
	jwtSecret        []byte
	tokenExpiry      time.Duration
	rateLimiters     map[string]*rate.Limiter
	rateLimiterMutex sync.RWMutex
	tlsConfig        *tls.Config
	auditLog         *AuditLogger
	rbac             *RBACManager
}

// NewAdvancedSecurityPlugin creates a new security plugin
func NewAdvancedSecurityPlugin(config map[string]any, logger *zap.Logger) *AdvancedSecurityPlugin {
	plugin := &AdvancedSecurityPlugin{
		BasePlugin:   plugins.NewBasePlugin("advanced-security", "1.0.0", core.PluginTypeSecurity, logger),
		rateLimiters: make(map[string]*rate.Limiter),
		auditLog:     NewAuditLogger(logger),
		rbac:         NewRBACManager(),
	}

	plugin.Initialize(config)

	return plugin
}

func (p *AdvancedSecurityPlugin) Initialize(config map[string]any) error {
	p.BasePlugin.Initialize(config)

	// JWT configuration
	if secret, ok := config["jwt_secret"].(string); ok {
		p.jwtSecret = []byte(secret)
	}

	if expiry, ok := config["token_expiry"].(int); ok {
		p.tokenExpiry = time.Duration(expiry) * time.Hour
	} else {
		p.tokenExpiry = 24 * time.Hour
	}

	// Rate limiting configuration
	if rps, ok := config["rate_limit_rps"].(int); ok {
		p.configureDefaultRateLimit(rps)
	}

	// TLS configuration
	if requireTLS, ok := config["require_tls"].(bool); ok && requireTLS {
		p.configureTLS(config)
	}

	// RBAC configuration
	p.rbac.LoadPolicies(config)

	return nil
}

func (p *AdvancedSecurityPlugin) Start(ctx context.Context) error {
	p.BasePlugin.Start(ctx)
	p.auditLog.Start()
	return nil
}

func (p *AdvancedSecurityPlugin) Stop(ctx context.Context) error {
	p.auditLog.Stop()
	return p.BasePlugin.Stop(ctx)
}

// JWT Token Management
func (p *AdvancedSecurityPlugin) GenerateToken(tenantID core.TenantID, userID string, roles []string) (string, error) {
	claims := jwt.MapClaims{
		"tenant_id": tenantID,
		"user_id":   userID,
		"roles":     roles,
		"exp":       time.Now().Add(p.tokenExpiry).Unix(),
		"iat":       time.Now().Unix(),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(p.jwtSecret)
}

func (p *AdvancedSecurityPlugin) ValidateToken(tokenString string) (*TokenClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return p.jwtSecret, nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		return &TokenClaims{
			TenantID: core.TenantID(claims["tenant_id"].(string)),
			UserID:   claims["user_id"].(string),
			Roles:    interfaceSliceToStringSlice(claims["roles"].([]interface{})),
		}, nil
	}

	return nil, fmt.Errorf("invalid token")
}

// Rate Limiting
func (p *AdvancedSecurityPlugin) CheckRateLimit(key string) bool {
	p.rateLimiterMutex.RLock()
	limiter, exists := p.rateLimiters[key]
	p.rateLimiterMutex.RUnlock()

	if !exists {
		p.rateLimiterMutex.Lock()
		limiter = rate.NewLimiter(rate.Every(time.Second), 100)
		p.rateLimiters[key] = limiter
		p.rateLimiterMutex.Unlock()
	}

	return limiter.Allow()
}

func (p *AdvancedSecurityPlugin) configureDefaultRateLimit(rps int) {
	p.rateLimiters["default"] = rate.NewLimiter(rate.Every(time.Second/time.Duration(rps)), rps)
}

func (p *AdvancedSecurityPlugin) configureTLS(config map[string]any) {
	// TLS configuration would go here
	p.tlsConfig = &tls.Config{
		MinVersion: tls.VersionTLS13,
	}
}

// RBAC Authorization
func (p *AdvancedSecurityPlugin) Authorize(claims *TokenClaims, resource, action string) error {
	return p.rbac.CheckPermission(claims.Roles, resource, action)
}

// Audit Logging
func (p *AdvancedSecurityPlugin) AuditLog(event AuditEvent) {
	p.auditLog.Log(event)
}

// ============================================================================
// AUDIT LOGGER
// ============================================================================

type AuditLogger struct {
	logger  *zap.Logger
	events  chan AuditEvent
	storage AuditStorage
	running bool
}

type AuditEvent struct {
	Timestamp  time.Time              `json:"timestamp"`
	TenantID   core.TenantID          `json:"tenant_id"`
	UserID     string                 `json:"user_id"`
	Action     string                 `json:"action"`
	Resource   string                 `json:"resource"`
	ResourceID string                 `json:"resource_id,omitempty"`
	Result     string                 `json:"result"` // success, failure
	Details    map[string]interface{} `json:"details,omitempty"`
	IPAddress  string                 `json:"ip_address,omitempty"`
}

type AuditStorage interface {
	Store(event AuditEvent) error
	Query(tenantID core.TenantID, from, to time.Time) ([]AuditEvent, error)
}

func NewAuditLogger(logger *zap.Logger) *AuditLogger {
	return &AuditLogger{
		logger:  logger,
		events:  make(chan AuditEvent, 1000),
		storage: &InMemoryAuditStorage{events: []AuditEvent{}},
	}
}

func (a *AuditLogger) Start() {
	a.running = true
	go a.processEvents()
}

func (a *AuditLogger) Stop() {
	a.running = false
	close(a.events)
}

func (a *AuditLogger) Log(event AuditEvent) {
	if a.running {
		event.Timestamp = time.Now()
		a.events <- event
	}
}

func (a *AuditLogger) processEvents() {
	for event := range a.events {
		if err := a.storage.Store(event); err != nil {
			a.logger.Error("Failed to store audit event", zap.Error(err))
		}

		// Also log to structured logger
		a.logger.Info("Audit event",
			zap.Time("timestamp", event.Timestamp),
			zap.String("tenant_id", event.TenantID.String()),
			zap.String("user_id", event.UserID),
			zap.String("action", event.Action),
			zap.String("resource", event.Resource),
			zap.String("result", event.Result),
		)
	}
}

type InMemoryAuditStorage struct {
	events []AuditEvent
	mu     sync.RWMutex
}

func (s *InMemoryAuditStorage) Store(event AuditEvent) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.events = append(s.events, event)
	return nil
}

func (s *InMemoryAuditStorage) Query(tenantID core.TenantID, from, to time.Time) ([]AuditEvent, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var result []AuditEvent
	for _, event := range s.events {
		if event.TenantID == tenantID &&
			event.Timestamp.After(from) &&
			event.Timestamp.Before(to) {
			result = append(result, event)
		}
	}
	return result, nil
}

// ============================================================================
// RBAC MANAGER
// ============================================================================

type RBACManager struct {
	policies map[string]*Policy
	mu       sync.RWMutex
}

type Policy struct {
	Roles       []string
	Permissions []Permission
}

type Permission struct {
	Resource string
	Actions  []string
}

func NewRBACManager() *RBACManager {
	manager := &RBACManager{
		policies: make(map[string]*Policy),
	}

	// Default policies
	manager.AddPolicy("admin", Policy{
		Roles: []string{"admin"},
		Permissions: []Permission{
			{Resource: "*", Actions: []string{"*"}},
		},
	})

	manager.AddPolicy("operator", Policy{
		Roles: []string{"operator"},
		Permissions: []Permission{
			{Resource: "workflow", Actions: []string{"read", "execute", "cancel"}},
			{Resource: "definition", Actions: []string{"read"}},
		},
	})

	manager.AddPolicy("viewer", Policy{
		Roles: []string{"viewer"},
		Permissions: []Permission{
			{Resource: "*", Actions: []string{"read"}},
		},
	})

	return manager
}

func (r *RBACManager) AddPolicy(name string, policy Policy) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.policies[name] = &policy
}

func (r *RBACManager) LoadPolicies(config map[string]any) {
	// Load custom policies from configuration
}

func (r *RBACManager) CheckPermission(roles []string, resource, action string) error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for _, role := range roles {
		if policy, exists := r.policies[role]; exists {
			if r.hasPermission(policy, resource, action) {
				return nil
			}
		}
	}

	return fmt.Errorf("permission denied: %s %s for roles %v", action, resource, roles)
}

func (r *RBACManager) hasPermission(policy *Policy, resource, action string) bool {
	for _, perm := range policy.Permissions {
		if perm.Resource == "*" || perm.Resource == resource {
			for _, a := range perm.Actions {
				if a == "*" || a == action {
					return true
				}
			}
		}
	}
	return false
}

// ============================================================================
// ADVANCED OBSERVABILITY PLUGIN
// ============================================================================

type AdvancedObservabilityPlugin struct {
	*plugins.BasePlugin
	metricsRegistry *prometheus.Registry
	tracerProvider  *trace.TracerProvider
	metricsServer   *http.Server

	// Metrics
	workflowsActive    *prometheus.GaugeVec
	workflowsCompleted *prometheus.CounterVec
	workflowsFailed    *prometheus.CounterVec
	workflowDuration   *prometheus.HistogramVec
	nodesExecuted      *prometheus.CounterVec
	nodesFailed        *prometheus.CounterVec
	nodeDuration       *prometheus.HistogramVec
}

func NewAdvancedObservabilityPlugin(config map[string]any, logger *zap.Logger) *AdvancedObservabilityPlugin {
	plugin := &AdvancedObservabilityPlugin{
		BasePlugin:      plugins.NewBasePlugin("advanced-observability", "1.0.0", core.PluginTypeObservability, logger),
		metricsRegistry: prometheus.NewRegistry(),
	}

	plugin.initializeMetrics()
	plugin.Initialize(config)

	return plugin
}

func (p *AdvancedObservabilityPlugin) Initialize(config map[string]any) error {
	p.BasePlugin.Initialize(config)

	// Initialize tracing
	if tracingEnabled, ok := config["tracing_enabled"].(bool); ok && tracingEnabled {
		endpoint := config["tracing_endpoint"].(string)
		p.initializeTracing(endpoint)
	}

	return nil
}

func (p *AdvancedObservabilityPlugin) Start(ctx context.Context) error {
	p.BasePlugin.Start(ctx)

	// Start metrics server
	metricsPort := p.GetConfig()["metrics_port"].(int)
	p.startMetricsServer(metricsPort)

	return nil
}

func (p *AdvancedObservabilityPlugin) Stop(ctx context.Context) error {
	if p.metricsServer != nil {
		p.metricsServer.Shutdown(ctx)
	}

	if p.tracerProvider != nil {
		p.tracerProvider.Shutdown(ctx)
	}

	return p.BasePlugin.Stop(ctx)
}

func (p *AdvancedObservabilityPlugin) initializeMetrics() {
	// Workflow metrics
	p.workflowsActive = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "golek_workflows_active_total",
			Help: "Number of currently active workflows",
		},
		[]string{"tenant_id", "definition_id"},
	)

	p.workflowsCompleted = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "golek_workflows_completed_total",
			Help: "Total number of completed workflows",
		},
		[]string{"tenant_id", "definition_id", "status"},
	)

	p.workflowsFailed = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "golek_workflows_failed_total",
			Help: "Total number of failed workflows",
		},
		[]string{"tenant_id", "definition_id", "error_code"},
	)

	p.workflowDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "golek_workflow_duration_seconds",
			Help:    "Workflow execution duration in seconds",
			Buckets: prometheus.ExponentialBuckets(1, 2, 10), // 1s, 2s, 4s, ..., 512s
		},
		[]string{"tenant_id", "definition_id"},
	)

	// Node metrics
	p.nodesExecuted = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "golek_nodes_executed_total",
			Help: "Total number of executed nodes",
		},
		[]string{"tenant_id", "definition_id", "node_id", "executor_type"},
	)

	p.nodesFailed = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "golek_nodes_failed_total",
			Help: "Total number of failed nodes",
		},
		[]string{"tenant_id", "definition_id", "node_id", "error_code"},
	)

	p.nodeDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "golek_node_execution_duration_seconds",
			Help:    "Node execution duration in seconds",
			Buckets: prometheus.ExponentialBuckets(0.1, 2, 10), // 0.1s, 0.2s, 0.4s, ..., 51.2s
		},
		[]string{"tenant_id", "definition_id", "node_id"},
	)

	// Register metrics
	p.metricsRegistry.MustRegister(
		p.workflowsActive,
		p.workflowsCompleted,
		p.workflowsFailed,
		p.workflowDuration,
		p.nodesExecuted,
		p.nodesFailed,
		p.nodeDuration,
	)
}

func (p *AdvancedObservabilityPlugin) initializeTracing(endpoint string) {
	ctx := context.Background()

	exporter, err := otlptracegrpc.New(ctx,
		otlptracegrpc.WithEndpoint(endpoint),
		otlptracegrpc.WithInsecure(),
	)

	if err != nil {
		p.logger.Error("Failed to create trace exporter", zap.Error(err))
		return
	}

	p.tracerProvider = trace.NewTracerProvider(
		trace.WithBatcher(exporter),
		trace.WithSampler(trace.AlwaysSample()),
	)

	otel.SetTracerProvider(p.tracerProvider)

	p.logger.Info("Distributed tracing initialized", zap.String("endpoint", endpoint))
}

func (p *AdvancedObservabilityPlugin) startMetricsServer(port int) {
	mux := http.NewServeMux()
	mux.Handle("/metrics", promhttp.HandlerFor(p.metricsRegistry, promhttp.HandlerOpts{}))

	p.metricsServer = &http.Server{
		Addr:    fmt.Sprintf(":%d", port),
		Handler: mux,
	}

	go func() {
		p.logger.Info("Metrics server started", zap.Int("port", port))
		if err := p.metricsServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			p.logger.Error("Metrics server error", zap.Error(err))
		}
	}()
}

// Metric recording methods
func (p *AdvancedObservabilityPlugin) RecordWorkflowStarted(tenantID core.TenantID, definitionID core.WorkflowDefinitionID) {
	p.workflowsActive.WithLabelValues(tenantID.String(), definitionID.String()).Inc()
}

func (p *AdvancedObservabilityPlugin) RecordWorkflowCompleted(tenantID core.TenantID, definitionID core.WorkflowDefinitionID, status string, duration time.Duration) {
	p.workflowsActive.WithLabelValues(tenantID.String(), definitionID.String()).Dec()
	p.workflowsCompleted.WithLabelValues(tenantID.String(), definitionID.String(), status).Inc()
	p.workflowDuration.WithLabelValues(tenantID.String(), definitionID.String()).Observe(duration.Seconds())
}

func (p *AdvancedObservabilityPlugin) RecordWorkflowFailed(tenantID core.TenantID, definitionID core.WorkflowDefinitionID, errorCode string) {
	p.workflowsActive.WithLabelValues(tenantID.String(), definitionID.String()).Dec()
	p.workflowsFailed.WithLabelValues(tenantID.String(), definitionID.String(), errorCode).Inc()
}

func (p *AdvancedObservabilityPlugin) RecordNodeExecuted(tenantID core.TenantID, definitionID core.WorkflowDefinitionID, nodeID core.NodeID, executorType string, duration time.Duration) {
	p.nodesExecuted.WithLabelValues(tenantID.String(), definitionID.String(), nodeID.String(), executorType).Inc()
	p.nodeDuration.WithLabelValues(tenantID.String(), definitionID.String(), nodeID.String()).Observe(duration.Seconds())
}

func (p *AdvancedObservabilityPlugin) RecordNodeFailed(tenantID core.TenantID, definitionID core.WorkflowDefinitionID, nodeID core.NodeID, errorCode string) {
	p.nodesFailed.WithLabelValues(tenantID.String(), definitionID.String(), nodeID.String(), errorCode).Inc()
}

// ============================================================================
// CIRCUIT BREAKER PLUGIN
// ============================================================================

type CircuitBreakerPlugin struct {
	*plugins.BasePlugin
	breakers map[string]*CircuitBreaker
	mu       sync.RWMutex
}

type CircuitBreaker struct {
	name            string
	maxFailures     int
	resetTimeout    time.Duration
	state           CircuitState
	failures        int
	lastFailureTime time.Time
	mu              sync.RWMutex
}

type CircuitState string

const (
	StateClosed   CircuitState = "CLOSED"
	StateOpen     CircuitState = "OPEN"
	StateHalfOpen CircuitState = "HALF_OPEN"
)

func NewCircuitBreakerPlugin(config map[string]any, logger *zap.Logger) *CircuitBreakerPlugin {
	plugin := &CircuitBreakerPlugin{
		BasePlugin: plugins.NewBasePlugin("circuit-breaker", "1.0.0", core.PluginTypeMiddleware, logger),
		breakers:   make(map[string]*CircuitBreaker),
	}

	plugin.Initialize(config)

	return plugin
}

func (p *CircuitBreakerPlugin) GetBreaker(name string) *CircuitBreaker {
	p.mu.RLock()
	breaker, exists := p.breakers[name]
	p.mu.RUnlock()

	if !exists {
		p.mu.Lock()
		breaker = &CircuitBreaker{
			name:         name,
			maxFailures:  5,
			resetTimeout: 60 * time.Second,
			state:        StateClosed,
		}
		p.breakers[name] = breaker
		p.mu.Unlock()
	}

	return breaker
}

func (cb *CircuitBreaker) Call(fn func() error) error {
	cb.mu.Lock()

	// Check if circuit is open
	if cb.state == StateOpen {
		if time.Since(cb.lastFailureTime) > cb.resetTimeout {
			// Try half-open
			cb.state = StateHalfOpen
			cb.mu.Unlock()
		} else {
			cb.mu.Unlock()
			return fmt.Errorf("circuit breaker open for %s", cb.name)
		}
	} else {
		cb.mu.Unlock()
	}

	// Execute function
	err := fn()

	cb.mu.Lock()
	defer cb.mu.Unlock()

	if err != nil {
		cb.failures++
		cb.lastFailureTime = time.Now()

		if cb.failures >= cb.maxFailures {
			cb.state = StateOpen
		}

		return err
	}

	// Success - reset
	if cb.state == StateHalfOpen {
		cb.state = StateClosed
	}
	cb.failures = 0

	return nil
}

// ============================================================================
// HELPER TYPES
// ============================================================================

type TokenClaims struct {
	TenantID core.TenantID
	UserID   string
	Roles    []string
}

func interfaceSliceToStringSlice(slice []interface{}) []string {
	result := make([]string, len(slice))
	for i, v := range slice {
		result[i] = v.(string)
	}
	return result
}
