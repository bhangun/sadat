# golek Workflow Engine

**Enterprise-grade, polyglot workflow orchestration engine for Agentic AI, Enterprise Integration Patterns, and Business Automation**

[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)
[![Go Version](https://img.shields.io/badge/go-1.21+-blue.svg)](https://golang.org)
[![gRPC](https://img.shields.io/badge/grpc-v1.60+-green.svg)](https://grpc.io)

---

## ðŸŽ¯ Overview

golek is a production-ready, cloud-native workflow orchestration engine designed for modern distributed systems. It provides a unified platform for:

- **Agentic AI Orchestration**: Coordinate AI agents, LLMs, and autonomous systems
- **Enterprise Integration Patterns (EIP)**: Message routing, transformation, and integration
- **Business Process Automation**: BPMN-compatible workflow execution
- **SAGA Pattern**: Distributed transaction management with automatic compensation
- **Human-in-the-Loop**: Approval workflows and manual interventions

## âœ¨ Key Features

### Core Capabilities
- âœ… **Multi-Tenancy**: Complete tenant isolation at all layers
- âœ… **Event Sourcing**: Full audit trail and time-travel debugging
- âœ… **Distributed Locking**: PostgreSQL-based distributed locks
- âœ… **Plugin System**: Hot-pluggable architecture (enable/disable at runtime)
- âœ… **Multiple Communication Protocols**: gRPC, REST, Kafka, NATS
- âœ… **SAGA Pattern**: Automatic compensation for distributed transactions
- âœ… **Polyglot Executors**: SDKs for Go, Java/Quarkus, Python

### Production-Ready
- âœ… **High Availability**: Stateless engine design, horizontal scaling
- âœ… **Observability**: Prometheus metrics, distributed tracing (OpenTelemetry)
- âœ… **Security**: JWT authentication, TLS support, rate limiting
- âœ… **Retry Mechanisms**: Exponential backoff with jitter
- âœ… **Graceful Shutdown**: Clean termination of in-flight workflows
- âœ… **Health Checks**: Liveness and readiness probes

---

## ðŸ—ï¸ Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Control Plane (Optional)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Visual      â”‚  â”‚  AI Agent    â”‚  â”‚  Integration â”‚          â”‚
â”‚  â”‚  Designer    â”‚  â”‚  Management  â”‚  â”‚  Patterns    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       golek Engine                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Workflow Engine     Event Store      Plugin Registry   â”‚   â”‚
â”‚  â”‚  â€¢ Run Manager       â€¢ PostgreSQL     â€¢ Security        â”‚   â”‚
â”‚  â”‚  â€¢ Scheduler         â€¢ Kafka          â€¢ Storage         â”‚   â”‚
â”‚  â”‚  â€¢ Compensation      â€¢ Event Bus      â€¢ Messaging       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   REST API   â”‚  â”‚   gRPC API   â”‚  â”‚  GraphQL API â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                                              â”‚
        â–¼                                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Executors   â”‚                              â”‚  Executors   â”‚
â”‚  (Go)        â”‚                              â”‚  (Java)      â”‚
â”‚              â”‚                              â”‚              â”‚
â”‚ â€¢ Order      â”‚                              â”‚ â€¢ Payment    â”‚
â”‚ â€¢ Validator  â”‚                              â”‚ â€¢ Processor  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                              â”‚
        â–¼                                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Executors   â”‚                              â”‚  Executors   â”‚
â”‚  (Python)    â”‚                              â”‚  (Custom)    â”‚
â”‚              â”‚                              â”‚              â”‚
â”‚ â€¢ AI Agent   â”‚                              â”‚ â€¢ Any Lang   â”‚
â”‚ â€¢ ML Model   â”‚                              â”‚ â€¢ Protocol   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸš€ Quick Start

### Prerequisites
- Go 1.21+
- PostgreSQL 15+
- Kafka 3.0+ (optional)
- Docker & Docker Compose

### Installation

#### 1. Using Docker Compose (Recommended)

```bash
# Clone repository
git clone https://github.com/kayys/golek.git
cd golek

# Start all services
docker-compose up -d

# Check status
docker-compose ps
```

Services will be available at:
- **REST API**: http://localhost:8080
- **gRPC API**: localhost:9090
- **Metrics**: http://localhost:9090/metrics

#### 2. From Source

```bash
# Build engine
cd cmd/engine
go build -o golek-engine

# Run migrations
./golek-engine migrate

# Start engine
./golek-engine serve --config config.yaml
```

### Your First Workflow

#### 1. Define Workflow (Go Client)

```go
package main

import (
    "context"
    "github.com/kayys/golek/pkg/client"
)

func main() {
    // Create client
    client := golek.NewClient("localhost:9090", "my-tenant")
    
    // Define workflow
    definition, _ := client.Definitions().
        Create("order-processing", "1.0.0").
        Description("E-commerce order processing").
        AddNode(golek.Node{
            ID:           "validate-order",
            Name:         "Validate Order",
            Type:         "TASK",
            ExecutorType: "order-validator",
        }).
        AddNode(golek.Node{
            ID:           "process-payment",
            Name:         "Process Payment",
            Type:         "TASK",
            ExecutorType: "payment-processor",
            DependsOn:    []string{"validate-order"},
        }).
        Execute(context.Background())
    
    // Create and start run
    run, _ := client.Workflows().
        Create(definition.ID).
        Input("orderId", "ORDER-123").
        Input("amount", 99.99).
        ExecuteAndStart(context.Background())
    
    println("Workflow started:", run.ID)
}
```

#### 2. Define Workflow (Java/Quarkus)

```java
import tech.kayys.golek.client.golekClient;

@ApplicationScoped
public class WorkflowService {
    
    @Inject
    golekClient client;
    
    public void createOrderWorkflow() {
        // Define workflow
        WorkflowDefinition def = client.definitions()
            .create("order-processing", "1.0.0")
            .description("Order processing workflow")
            .addNode(new NodeDefinitionDto(
                "validate-order", "Validate Order", 
                "TASK", "order-validator"))
            .addNode(new NodeDefinitionDto(
                "process-payment", "Process Payment", 
                "TASK", "payment-processor"))
            .execute()
            .await().indefinitely();
        
        // Execute workflow
        WorkflowRun run = client.workflows()
            .create(def.getDefinitionId())
            .input("orderId", "ORDER-123")
            .input("amount", 99.99)
            .executeAndStart()
            .await().indefinitely();
        
        System.out.println("Workflow started: " + run.getRunId());
    }
}
```

#### 3. Create Executor (Python)

```python
from golek.executor import Executor, Task, Result, executor, success, failure

@executor(
    executor_type="order-validator",
    max_concurrent=20,
    capabilities=["validation", "orders"]
)
class OrderValidatorExecutor(Executor):
    
    async def execute(self, task: Task) -> Result:
        # Extract order data
        order_id = task.context.get("orderId")
        amount = task.context.get("amount")
        
        # Validate
        if not order_id or not order_id.startswith("ORDER-"):
            return failure("INVALID_ORDER", "Invalid order ID")
        
        if amount <= 0:
            return failure("INVALID_AMOUNT", "Amount must be positive")
        
        # Success
        return success({
            "valid": True,
            "validatedAt": "2024-01-01T00:00:00Z"
        })

# Run executor
if __name__ == "__main__":
    executor = OrderValidatorExecutor()
    executor.run()
```

---

## ðŸ“š Advanced Features

### SAGA Pattern (Distributed Transactions)

The SAGA pattern provides automatic compensation for failed distributed transactions:

```go
// Define SAGA
saga := NewSAGA("order-saga", "Order Processing SAGA", tenantID).
    AddStep("reserve-inventory", "Reserve Inventory",
        "reserve-inventory-wf", "release-inventory-wf").
    WithInput("orderId", orderID).
    WithTimeout(60).
    
    AddStep("charge-payment", "Charge Payment",
        "charge-payment-wf", "refund-payment-wf").
    WithInput("amount", totalAmount).
    WithTimeout(120).
    
    AddStep("create-shipment", "Create Shipment",
        "create-shipment-wf", "cancel-shipment-wf").
    WithTimeout(180).
    
    Build()

// Execute SAGA
coordinator := NewSAGACoordinator(engine, logger)
execution, err := coordinator.ExecuteSAGA(ctx, saga)

if err != nil {
    // SAGA failed and was automatically compensated
    log.Printf("SAGA failed and compensated: %v", err)
} else {
    log.Printf("SAGA completed successfully: %s", execution.ID)
}
```

**Java Example:**

```java
@Inject
golekClient client;

public void executeSAGA() {
    SAGAExecution execution = client.sagas()
        .create("order-saga", "Order SAGA")
        .addStep("reserve-inventory", "Reserve Inventory",
            "reserve-wf", "release-wf")
        .withStepInput("orderId", orderId)
        .withStepTimeout(60)
        
        .addStep("charge-payment", "Charge Payment",
            "charge-wf", "refund-wf")
        .withStepInput("amount", amount)
        
        .execute()
        .await().indefinitely();
    
    if (execution.getStatus() == SAGAStatus.COMPENSATED) {
        // Handle compensation
    }
}
```

### Plugin System

Enable/disable features at runtime:

```yaml
# config.yaml
plugins:
  plugins:
    - name: postgres-storage
      type: storage
      version: 1.0.0
      enabled: true
      config:
        pool_size: 25
    
    - name: kafka-messaging
      type: messaging
      version: 1.0.0
      enabled: true
      config:
        brokers: ["kafka:9092"]
    
    - name: security-jwt
      type: security
      version: 1.0.0
      enabled: true
      config:
        jwt_secret: "your-secret-key"
    
    - name: observability-prometheus
      type: observability
      version: 1.0.0
      enabled: true
```

### Multi-Protocol Communication

Executors can use different protocols:

```yaml
# Executor 1: gRPC (default, best performance)
executor:
  type: order-validator
  communication: grpc
  endpoint: executor1:9091

# Executor 2: Kafka (async, scalable)
executor:
  type: payment-processor
  communication: kafka
  topic: golek-payments

# Executor 3: REST (legacy systems)
executor:
  type: legacy-system
  communication: rest
  endpoint: http://legacy:8080
```

---

## ðŸ”§ Configuration

### Complete Configuration Example

```yaml
server:
  rest_enabled: true
  rest_port: 8080
  grpc_enabled: true
  grpc_port: 9090
  graphql_enabled: false

database:
  type: postgres
  host: localhost
  port: 5432
  database: golek
  username: golek
  password: ${DATABASE_PASSWORD}
  max_connections: 25
  ssl_mode: require

messaging:
  type: kafka
  brokers:
    - kafka1:9092
    - kafka2:9092
  topic: golek-events
  group_id: golek-engine

engine:
  max_concurrent_runs: 1000
  node_execution_timeout: 300
  enable_event_sourcing: true
  enable_compensation: true

security:
  enabled: true
  jwt_secret: ${JWT_SECRET}
  token_expiry: 24
  require_tls: true
  allowed_origins:
    - "https://app.example.com"
  rate_limit_enabled: true
  rate_limit_rps: 100

observability:
  metrics_enabled: true
  metrics_port: 9090
  tracing_enabled: true
  tracing_endpoint: "jaeger:4318"
  log_level: info
```

### Environment Variables

```bash
# Engine Configuration
golek_ENGINE_ENDPOINT=localhost:9090
golek_TENANT_ID=my-tenant

# Database
DATABASE_HOST=postgres
DATABASE_PASSWORD=secret

# Security
JWT_SECRET=your-secret-key-min-32-chars

# Messaging
KAFKA_BROKERS=kafka:9092

# Executors
EXECUTOR_TYPE=order-validator
EXECUTOR_MAX_CONCURRENT=20
```

---

## ðŸ“¦ Deployment

### Docker Compose (Development)

```yaml
version: '3.8'

services:
  # golek Engine
  golek-engine:
    image: golek/engine:latest
    ports:
      - "8080:8080"  # REST
      - "9090:9090"  # gRPC
    environment:
      - DATABASE_URL=postgres://golek:password@postgres:5432/golek
      - KAFKA_BROKERS=kafka:9092
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres
      - kafka

  # PostgreSQL
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: golek
      POSTGRES_USER: golek
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
    depends_on:
      - zookeeper

  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  # Executors
  order-validator:
    image: golek/executor-go:latest
    environment:
      EXECUTOR_TYPE: order-validator
      golek_ENGINE_ENDPOINT: golek-engine:9090
    deploy:
      replicas: 3

  payment-processor:
    image: golek/executor-java:latest
    environment:
      EXECUTOR_TYPE: payment-processor
      golek_ENGINE_ENDPOINT: golek-engine:9090
    deploy:
      replicas: 2

  ai-agent:
    image: golek/executor-python:latest
    environment:
      EXECUTOR_TYPE: ai-agent
      golek_ENGINE_ENDPOINT: golek-engine:9090
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    deploy:
      replicas: 1

volumes:
  postgres_data:
```

### Kubernetes (Production)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: golek-engine
spec:
  replicas: 3
  selector:
    matchLabels:
      app: golek-engine
  template:
    metadata:
      labels:
        app: golek-engine
    spec:
      containers:
      - name: engine
        image: golek/engine:1.0.0
        ports:
        - containerPort: 8080
          name: rest
        - containerPort: 9090
          name: grpc
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: golek-secrets
              key: database-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: golek-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: golek-engine
spec:
  selector:
    app: golek-engine
  ports:
  - name: rest
    port: 8080
    targetPort: 8080
  - name: grpc
    port: 9090
    targetPort: 9090
  type: LoadBalancer
```

---

## ðŸ“Š Monitoring & Observability

### Prometheus Metrics

```prometheus
# Workflow metrics
golek_workflows_active_total
golek_workflows_completed_total
golek_workflows_failed_total
golek_workflow_duration_seconds

# Node metrics
golek_nodes_executed_total
golek_nodes_failed_total
golek_node_execution_duration_seconds

# Executor metrics
golek_executor_tasks_started_total
golek_executor_tasks_completed_total
golek_executor_tasks_failed_total
golek_executor_active_connections
```

### Distributed Tracing

golek supports OpenTelemetry for distributed tracing:

```go
// Configure tracing
tracer := otel.Tracer("golek-engine")

ctx, span := tracer.Start(ctx, "workflow-execution")
defer span.End()

span.SetAttributes(
    attribute.String("workflow.id", workflowID),
    attribute.String("tenant.id", tenantID),
)
```

---

## ðŸ¤ Contributing

We welcome contributions! See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

## ðŸ“„ License

Apache License 2.0 - see [LICENSE](LICENSE) for details.

## ðŸ™ Acknowledgments

- Inspired by Temporal, Cadence, and Apache Airflow
- Built with Go, gRPC, PostgreSQL, and Kafka
- Community feedback and contributions

---

## ðŸ“ž Support

- **Documentation**: https://docs.golek.dev
- **Issues**: https://github.com/kayys/golek/issues
- **Discord**: https://discord.gg/golek
- **Email**: support@golek.dev

**Made with â¤ï¸ by the golek team**