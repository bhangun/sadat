// Package plugins provides a modular plugin system for extending golek functionality
package plugins

import (
	"context"
	"fmt"
	"sync"

	"go.uber.org/zap"

	"tech.kayys.golek/pkg/core"
)

// ============================================================================
// PLUGIN REGISTRY
// ============================================================================

// DefaultPluginRegistry manages plugin lifecycle and registration
type DefaultPluginRegistry struct {
	plugins        map[string]core.Plugin
	enabledPlugins map[string]bool
	logger         *zap.Logger
	mu             sync.RWMutex
}

// NewPluginRegistry creates a new plugin registry
func NewPluginRegistry(logger *zap.Logger) *DefaultPluginRegistry {
	return &DefaultPluginRegistry{
		plugins:        make(map[string]core.Plugin),
		enabledPlugins: make(map[string]bool),
		logger:         logger,
	}
}

// Register registers a new plugin
func (r *DefaultPluginRegistry) Register(plugin core.Plugin) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	name := plugin.Name()

	if _, exists := r.plugins[name]; exists {
		return fmt.Errorf("plugin already registered: %s", name)
	}

	// Validate configuration
	if err := plugin.ValidateConfig(plugin.DefaultConfig()); err != nil {
		return fmt.Errorf("invalid default config for plugin %s: %w", name, err)
	}

	r.plugins[name] = plugin
	r.enabledPlugins[name] = false // Disabled by default

	r.logger.Info("Plugin registered",
		zap.String("name", name),
		zap.String("version", plugin.Version()),
		zap.String("type", string(plugin.Type())),
	)

	return nil
}

// Unregister removes a plugin
func (r *DefaultPluginRegistry) Unregister(name string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	plugin, exists := r.plugins[name]
	if !exists {
		return fmt.Errorf("plugin not found: %s", name)
	}

	// Stop plugin if enabled
	if r.enabledPlugins[name] {
		ctx := context.Background()
		if err := plugin.Stop(ctx); err != nil {
			r.logger.Error("Failed to stop plugin during unregister",
				zap.String("plugin", name),
				zap.Error(err),
			)
		}
	}

	delete(r.plugins, name)
	delete(r.enabledPlugins, name)

	r.logger.Info("Plugin unregistered", zap.String("name", name))

	return nil
}

// Get retrieves a plugin by name
func (r *DefaultPluginRegistry) Get(name string) (core.Plugin, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	plugin, exists := r.plugins[name]
	if !exists {
		return nil, fmt.Errorf("plugin not found: %s", name)
	}

	return plugin, nil
}

// List returns all registered plugins
func (r *DefaultPluginRegistry) List() []core.Plugin {
	r.mu.RLock()
	defer r.mu.RUnlock()

	plugins := make([]core.Plugin, 0, len(r.plugins))
	for _, plugin := range r.plugins {
		plugins = append(plugins, plugin)
	}

	return plugins
}

// EnablePlugin enables and starts a plugin
func (r *DefaultPluginRegistry) EnablePlugin(name string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	plugin, exists := r.plugins[name]
	if !exists {
		return fmt.Errorf("plugin not found: %s", name)
	}

	if r.enabledPlugins[name] {
		return nil // Already enabled
	}

	// Initialize plugin
	config := plugin.DefaultConfig()
	if err := plugin.Initialize(config); err != nil {
		return fmt.Errorf("failed to initialize plugin %s: %w", name, err)
	}

	// Start plugin
	ctx := context.Background()
	if err := plugin.Start(ctx); err != nil {
		return fmt.Errorf("failed to start plugin %s: %w", name, err)
	}

	r.enabledPlugins[name] = true

	r.logger.Info("Plugin enabled", zap.String("name", name))

	return nil
}

// DisablePlugin stops and disables a plugin
func (r *DefaultPluginRegistry) DisablePlugin(name string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	plugin, exists := r.plugins[name]
	if !exists {
		return fmt.Errorf("plugin not found: %s", name)
	}

	if !r.enabledPlugins[name] {
		return nil // Already disabled
	}

	// Stop plugin
	ctx := context.Background()
	if err := plugin.Stop(ctx); err != nil {
		return fmt.Errorf("failed to stop plugin %s: %w", name, err)
	}

	r.enabledPlugins[name] = false

	r.logger.Info("Plugin disabled", zap.String("name", name))

	return nil
}

// IsEnabled checks if a plugin is enabled
func (r *DefaultPluginRegistry) IsEnabled(name string) bool {
	r.mu.RLock()
	defer r.mu.RUnlock()

	return r.enabledPlugins[name]
}

// StartAll starts all enabled plugins
func (r *DefaultPluginRegistry) StartAll(ctx context.Context) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	for name, plugin := range r.plugins {
		if r.enabledPlugins[name] {
			if err := plugin.Start(ctx); err != nil {
				r.logger.Error("Failed to start plugin",
					zap.String("plugin", name),
					zap.Error(err),
				)
				// Continue with other plugins
			}
		}
	}

	return nil
}

// StopAll stops all plugins
func (r *DefaultPluginRegistry) StopAll(ctx context.Context) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	for name, plugin := range r.plugins {
		if r.enabledPlugins[name] {
			if err := plugin.Stop(ctx); err != nil {
				r.logger.Error("Failed to stop plugin",
					zap.String("plugin", name),
					zap.Error(err),
				)
			}
		}
	}

	return nil
}

// HealthCheckAll performs health check on all enabled plugins
func (r *DefaultPluginRegistry) HealthCheckAll(ctx context.Context) map[string]error {
	r.mu.RLock()
	defer r.mu.RUnlock()

	results := make(map[string]error)

	for name, plugin := range r.plugins {
		if r.enabledPlugins[name] {
			results[name] = plugin.HealthCheck(ctx)
		}
	}

	return results
}

// ============================================================================
// BASE PLUGIN IMPLEMENTATION
// ============================================================================

// BasePlugin provides common plugin functionality
type BasePlugin struct {
	name    string
	version string
	pType   core.PluginType
	config  map[string]any
	logger  *zap.Logger
	mu      sync.RWMutex
}

// NewBasePlugin creates a new base plugin
func NewBasePlugin(name, version string, pType core.PluginType, logger *zap.Logger) *BasePlugin {
	return &BasePlugin{
		name:    name,
		version: version,
		pType:   pType,
		logger:  logger,
	}
}

func (p *BasePlugin) Name() string          { return p.name }
func (p *BasePlugin) Version() string       { return p.version }
func (p *BasePlugin) Type() core.PluginType { return p.pType }

func (p *BasePlugin) Initialize(config map[string]any) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	p.config = config
	p.logger.Info("Plugin initialized", zap.String("name", p.name))
	return nil
}

func (p *BasePlugin) Start(ctx context.Context) error {
	p.logger.Info("Plugin started", zap.String("name", p.name))
	return nil
}

func (p *BasePlugin) Stop(ctx context.Context) error {
	p.logger.Info("Plugin stopped", zap.String("name", p.name))
	return nil
}

func (p *BasePlugin) HealthCheck(ctx context.Context) error {
	return nil
}

func (p *BasePlugin) DefaultConfig() map[string]any {
	return make(map[string]any)
}

func (p *BasePlugin) ValidateConfig(config map[string]any) error {
	return nil
}

func (p *BasePlugin) GetConfig() map[string]any {
	p.mu.RLock()
	defer p.mu.RUnlock()

	// Return copy
	configCopy := make(map[string]any)
	for k, v := range p.config {
		configCopy[k] = v
	}
	return configCopy
}

// ============================================================================
// PLUGIN LOADER
// ============================================================================

// PluginLoader loads plugins from configuration
type PluginLoader struct {
	registry *DefaultPluginRegistry
	logger   *zap.Logger
}

// NewPluginLoader creates a new plugin loader
func NewPluginLoader(registry *DefaultPluginRegistry, logger *zap.Logger) *PluginLoader {
	return &PluginLoader{
		registry: registry,
		logger:   logger,
	}
}

// LoadFromConfig loads plugins from configuration
func (l *PluginLoader) LoadFromConfig(config *PluginConfig) error {
	l.logger.Info("Loading plugins from configuration",
		zap.Int("count", len(config.Plugins)),
	)

	for _, pluginCfg := range config.Plugins {
		plugin, err := l.createPlugin(pluginCfg)
		if err != nil {
			l.logger.Error("Failed to create plugin",
				zap.String("name", pluginCfg.Name),
				zap.Error(err),
			)
			continue
		}

		if err := l.registry.Register(plugin); err != nil {
			l.logger.Error("Failed to register plugin",
				zap.String("name", pluginCfg.Name),
				zap.Error(err),
			)
			continue
		}

		// Enable if configured
		if pluginCfg.Enabled {
			if err := l.registry.EnablePlugin(pluginCfg.Name); err != nil {
				l.logger.Error("Failed to enable plugin",
					zap.String("name", pluginCfg.Name),
					zap.Error(err),
				)
			}
		}
	}

	return nil
}

// createPlugin creates a plugin instance from configuration
func (l *PluginLoader) createPlugin(cfg PluginConfigEntry) (core.Plugin, error) {
	// Factory pattern for creating plugins based on type
	switch cfg.Type {
	case "security":
		return NewSecurityPlugin(cfg.Name, cfg.Version, cfg.Config, l.logger), nil
	case "storage":
		return NewStoragePlugin(cfg.Name, cfg.Version, cfg.Config, l.logger), nil
	case "messaging":
		return NewMessagingPlugin(cfg.Name, cfg.Version, cfg.Config, l.logger), nil
	case "observability":
		return NewObservabilityPlugin(cfg.Name, cfg.Version, cfg.Config, l.logger), nil
	default:
		return nil, fmt.Errorf("unknown plugin type: %s", cfg.Type)
	}
}

// PluginConfig represents plugin configuration
type PluginConfig struct {
	Plugins []PluginConfigEntry `json:"plugins" yaml:"plugins"`
}

// PluginConfigEntry represents a single plugin configuration
type PluginConfigEntry struct {
	Name    string         `json:"name" yaml:"name"`
	Type    string         `json:"type" yaml:"type"`
	Version string         `json:"version" yaml:"version"`
	Enabled bool           `json:"enabled" yaml:"enabled"`
	Config  map[string]any `json:"config" yaml:"config"`
}

// ============================================================================
// EXAMPLE PLUGIN IMPLEMENTATIONS
// ============================================================================

// SecurityPlugin handles authentication and authorization
type SecurityPlugin struct {
	*BasePlugin
}

func NewSecurityPlugin(name, version string, config map[string]any, logger *zap.Logger) *SecurityPlugin {
	return &SecurityPlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeSecurity, logger),
	}
}

func (p *SecurityPlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"jwt_secret":         "change-me",
		"token_expiry":       "1h",
		"require_2fa":        false,
		"max_login_attempts": 5,
	}
}

func (p *SecurityPlugin) ValidateConfig(config map[string]any) error {
	if secret, ok := config["jwt_secret"].(string); ok {
		if secret == "change-me" || len(secret) < 32 {
			return fmt.Errorf("jwt_secret must be at least 32 characters")
		}
	}
	return nil
}

// StoragePlugin handles data persistence
type StoragePlugin struct {
	*BasePlugin
}

func NewStoragePlugin(name, version string, config map[string]any, logger *zap.Logger) *StoragePlugin {
	return &StoragePlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeStorage, logger),
	}
}

func (p *StoragePlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"type":            "postgres",
		"connection_pool": 10,
		"max_idle_conns":  5,
		"enable_ssl":      true,
	}
}

// MessagingPlugin handles message broker integration
type MessagingPlugin struct {
	*BasePlugin
}

func NewMessagingPlugin(name, version string, config map[string]any, logger *zap.Logger) *MessagingPlugin {
	return &MessagingPlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeMessaging, logger),
	}
}

func (p *MessagingPlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"type":               "kafka",
		"brokers":            []string{"localhost:9092"},
		"consumer_group":     "golek-engine",
		"auto_commit":        true,
		"enable_idempotence": true,
	}
}

// ObservabilityPlugin handles metrics, tracing, and logging
type ObservabilityPlugin struct {
	*BasePlugin
}

func NewObservabilityPlugin(name, version string, config map[string]any, logger *zap.Logger) *ObservabilityPlugin {
	return &ObservabilityPlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeObservability, logger),
	}
}

func (p *ObservabilityPlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"metrics_enabled":  true,
		"tracing_enabled":  true,
		"metrics_endpoint": ":9090",
		"tracing_endpoint": "localhost:4318",
		"sample_rate":      0.1,
	}
}

// ============================================================================
// PLUGIN HOOK SYSTEM
// ============================================================================

// Hook represents a lifecycle hook point
type Hook string

const (
	HookBeforeWorkflowStart    Hook = "before_workflow_start"
	HookAfterWorkflowStart     Hook = "after_workflow_start"
	HookBeforeNodeExecution    Hook = "before_node_execution"
	HookAfterNodeExecution     Hook = "after_node_execution"
	HookBeforeWorkflowComplete Hook = "before_workflow_complete"
	HookAfterWorkflowComplete  Hook = "after_workflow_complete"
	HookOnError                Hook = "on_error"
)

// HookHandler handles a specific hook
type HookHandler func(ctx context.Context, data map[string]any) error

// HookRegistry manages plugin hooks
type HookRegistry struct {
	hooks  map[Hook][]HookHandler
	logger *zap.Logger
	mu     sync.RWMutex
}

// NewHookRegistry creates a new hook registry
func NewHookRegistry(logger *zap.Logger) *HookRegistry {
	return &HookRegistry{
		hooks:  make(map[Hook][]HookHandler),
		logger: logger,
	}
}

// RegisterHook registers a hook handler
func (r *HookRegistry) RegisterHook(hook Hook, handler HookHandler) {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.hooks[hook] = append(r.hooks[hook], handler)
	r.logger.Info("Hook registered", zap.String("hook", string(hook)))
}

// ExecuteHooks executes all handlers for a hook
func (r *HookRegistry) ExecuteHooks(ctx context.Context, hook Hook, data map[string]any) error {
	r.mu.RLock()
	handlers := r.hooks[hook]
	r.mu.RUnlock()

	if len(handlers) == 0 {
		return nil
	}

	r.logger.Debug("Executing hooks",
		zap.String("hook", string(hook)),
		zap.Int("handlers", len(handlers)),
	)

	for _, handler := range handlers {
		if err := handler(ctx, data); err != nil {
			r.logger.Error("Hook execution failed",
				zap.String("hook", string(hook)),
				zap.Error(err),
			)
			return err
		}
	}

	return nil
}
