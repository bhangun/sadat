



// ============================================================================
// EXAMPLE PLUGIN IMPLEMENTATIONS
// ============================================================================

// SecurityPlugin handles authentication and authorization
type SecurityPlugin struct {
	*BasePlugin
}

func NewSecurityPlugin(name, version string, config map[string]any, logger *zap.Logger) *SecurityPlugin {
	return &SecurityPlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeSecurity, logger),
	}
}

func (p *SecurityPlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"jwt_secret":         "change-me",
		"token_expiry":       "1h",
		"require_2fa":        false,
		"max_login_attempts": 5,
	}
}

func (p *SecurityPlugin) ValidateConfig(config map[string]any) error {
	if secret, ok := config["jwt_secret"].(string); ok {
		if secret == "change-me" || len(secret) < 32 {
			return fmt.Errorf("jwt_secret must be at least 32 characters")
		}
	}
	return nil
}

// StoragePlugin handles data persistence
type StoragePlugin struct {
	*BasePlugin
}

func NewStoragePlugin(name, version string, config map[string]any, logger *zap.Logger) *StoragePlugin {
	return &StoragePlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeStorage, logger),
	}
}

func (p *StoragePlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"type":            "postgres",
		"connection_pool": 10,
		"max_idle_conns":  5,
		"enable_ssl":      true,
	}
}

// MessagingPlugin handles message broker integration
type MessagingPlugin struct {
	*BasePlugin
}

func NewMessagingPlugin(name, version string, config map[string]any, logger *zap.Logger) *MessagingPlugin {
	return &MessagingPlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeMessaging, logger),
	}
}

func (p *MessagingPlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"type":               "kafka",
		"brokers":            []string{"localhost:9092"},
		"consumer_group":     "golek-engine",
		"auto_commit":        true,
		"enable_idempotence": true,
	}
}

// ObservabilityPlugin handles metrics, tracing, and logging
type ObservabilityPlugin struct {
	*BasePlugin
}

func NewObservabilityPlugin(name, version string, config map[string]any, logger *zap.Logger) *ObservabilityPlugin {
	return &ObservabilityPlugin{
		BasePlugin: NewBasePlugin(name, version, core.PluginTypeObservability, logger),
	}
}

func (p *ObservabilityPlugin) DefaultConfig() map[string]any {
	return map[string]any{
		"metrics_enabled":  true,
		"tracing_enabled":  true,
		"metrics_endpoint": ":9090",
		"tracing_endpoint": "localhost:4318",
		"sample_rate":      0.1,
	}
}

// ============================================================================
// PLUGIN HOOK SYSTEM
// ============================================================================

// Hook represents a lifecycle hook point
type Hook string

const (
	HookBeforeWorkflowStart    Hook = "before_workflow_start"
	HookAfterWorkflowStart     Hook = "after_workflow_start"
	HookBeforeNodeExecution    Hook = "before_node_execution"
	HookAfterNodeExecution     Hook = "after_node_execution"
	HookBeforeWorkflowComplete Hook = "before_workflow_complete"
	HookAfterWorkflowComplete  Hook = "after_workflow_complete"
	HookOnError                Hook = "on_error"
)

// HookHandler handles a specific hook
type HookHandler func(ctx context.Context, data map[string]any) error

// HookRegistry manages plugin hooks
type HookRegistry struct {
	hooks  map[Hook][]HookHandler
	logger *zap.Logger
	mu     sync.RWMutex
}

// NewHookRegistry creates a new hook registry
func NewHookRegistry(logger *zap.Logger) *HookRegistry {
	return &HookRegistry{
		hooks:  make(map[Hook][]HookHandler),
		logger: logger,
	}
}

// RegisterHook registers a hook handler
func (r *HookRegistry) RegisterHook(hook Hook, handler HookHandler) {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.hooks[hook] = append(r.hooks[hook], handler)
	r.logger.Info("Hook registered", zap.String("hook", string(hook)))
}

// ExecuteHooks executes all handlers for a hook
func (r *HookRegistry) ExecuteHooks(ctx context.Context, hook Hook, data map[string]any) error {
	r.mu.RLock()
	handlers := r.hooks[hook]
	r.mu.RUnlock()

	if len(handlers) == 0 {
		return nil
	}

	r.logger.Debug("Executing hooks",
		zap.String("hook", string(hook)),
		zap.Int("handlers", len(handlers)),
	)

	for _, handler := range handlers {
		if err := handler(ctx, data); err != nil {
			r.logger.Error("Hook execution failed",
				zap.String("hook", string(hook)),
				zap.Error(err),
			)
			return err
		}
	}

	return nil
}
