// Package main provides example executor implementations
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"go.uber.org/zap"

	"tech.kayys.golek/pkg/executor"
)

// ============================================================================
// EXAMPLE 1: ORDER VALIDATOR EXECUTOR
// ============================================================================

// OrderValidatorExecutor validates order data
type OrderValidatorExecutor struct {
	logger *zap.Logger
}

func NewOrderValidatorExecutor(logger *zap.Logger) *OrderValidatorExecutor {
	return &OrderValidatorExecutor{
		logger: logger,
	}
}

func (e *OrderValidatorExecutor) Execute(ctx context.Context, task *executor.Task) (*executor.Result, error) {
	e.logger.Info("Validating order",
		zap.String("run_id", task.RunID),
		zap.String("node_id", task.NodeID),
	)

	// Extract order data from context
	orderID, ok := task.Context["orderId"].(string)
	if !ok || orderID == "" {
		return executor.FailureWithCode("INVALID_ORDER_ID", "Order ID is missing or invalid"), nil
	}

	items, ok := task.Context["items"].([]any)
	if !ok || len(items) == 0 {
		return executor.FailureWithCode("NO_ITEMS", "Order has no items"), nil
	}

	// Validate order ID format
	if len(orderID) < 5 || orderID[:6] != "ORDER-" {
		return executor.FailureWithCode("INVALID_FORMAT", "Order ID must start with ORDER-"), nil
	}

	// Validate items
	for i, item := range items {
		itemMap, ok := item.(map[string]any)
		if !ok {
			return executor.FailureWithCode("INVALID_ITEM", fmt.Sprintf("Item %d is invalid", i)), nil
		}

		if _, ok := itemMap["sku"]; !ok {
			return executor.FailureWithCode("MISSING_SKU", fmt.Sprintf("Item %d missing SKU", i)), nil
		}

		if _, ok := itemMap["quantity"]; !ok {
			return executor.FailureWithCode("MISSING_QUANTITY", fmt.Sprintf("Item %d missing quantity", i)), nil
		}
	}

	// Successful validation
	return executor.Success(map[string]any{
		"valid":       true,
		"validatedAt": time.Now().Format(time.RFC3339),
		"itemCount":   len(items),
		"warnings":    []string{},
	}), nil
}

func (e *OrderValidatorExecutor) Metadata() executor.ExecutorMetadata {
	return executor.ExecutorMetadata{
		Type:          "order-validator",
		Version:       "1.0.0",
		Capabilities:  []string{"validation", "orders"},
		MaxConcurrent: 20,
	}
}

func (e *OrderValidatorExecutor) HealthCheck(ctx context.Context) error {
	return nil
}

// ============================================================================
// EXAMPLE 2: PAYMENT PROCESSOR EXECUTOR
// ============================================================================

// PaymentProcessorExecutor processes payments
type PaymentProcessorExecutor struct {
	logger *zap.Logger
}

func NewPaymentProcessorExecutor(logger *zap.Logger) *PaymentProcessorExecutor {
	return &PaymentProcessorExecutor{
		logger: logger,
	}
}

func (e *PaymentProcessorExecutor) Execute(ctx context.Context, task *executor.Task) (*executor.Result, error) {
	e.logger.Info("Processing payment",
		zap.String("run_id", task.RunID),
		zap.String("node_id", task.NodeID),
	)

	// Extract payment data
	customerID, ok := task.Context["customerId"].(string)
	if !ok || customerID == "" {
		return executor.FailureWithCode("INVALID_CUSTOMER", "Customer ID is invalid"), nil
	}

	amount, ok := task.Context["totalAmount"].(float64)
	if !ok || amount <= 0 {
		return executor.FailureWithCode("INVALID_AMOUNT", "Amount must be positive"), nil
	}

	// Simulate payment processing
	e.logger.Info("Charging customer",
		zap.String("customer_id", customerID),
		zap.Float64("amount", amount),
	)

	// Simulate delay
	time.Sleep(500 * time.Millisecond)

	// Generate transaction ID
	transactionID := fmt.Sprintf("TXN-%d", time.Now().Unix())

	// Successful payment
	return executor.Success(map[string]any{
		"transactionId": transactionID,
		"status":        "COMPLETED",
		"amount":        amount,
		"currency":      "USD",
		"processedAt":   time.Now().Format(time.RFC3339),
	}), nil
}

func (e *PaymentProcessorExecutor) Metadata() executor.ExecutorMetadata {
	return executor.ExecutorMetadata{
		Type:          "payment-processor",
		Version:       "1.0.0",
		Capabilities:  []string{"payment", "stripe"},
		MaxConcurrent: 10,
	}
}

func (e *PaymentProcessorExecutor) HealthCheck(ctx context.Context) error {
	return nil
}

// ============================================================================
// EXAMPLE 3: AI AGENT EXECUTOR
// ============================================================================

// AIAgentExecutor executes AI agent tasks
type AIAgentExecutor struct {
	logger *zap.Logger
}

func NewAIAgentExecutor(logger *zap.Logger) *AIAgentExecutor {
	return &AIAgentExecutor{
		logger: logger,
	}
}

func (e *AIAgentExecutor) Execute(ctx context.Context, task *executor.Task) (*executor.Result, error) {
	e.logger.Info("Executing AI agent task",
		zap.String("run_id", task.RunID),
		zap.String("node_id", task.NodeID),
	)

	// Extract instruction
	instruction, ok := task.Context["instruction"].(string)
	if !ok || instruction == "" {
		return executor.FailureWithCode("NO_INSTRUCTION", "Instruction is required"), nil
	}

	// Get agent configuration
	model := "gpt-4"
	if m, ok := task.Config["model"].(string); ok {
		model = m
	}

	temperature := 0.7
	if t, ok := task.Config["temperature"].(float64); ok {
		temperature = t
	}

	e.logger.Info("Calling LLM",
		zap.String("model", model),
		zap.Float64("temperature", temperature),
		zap.String("instruction", instruction),
	)

	// Simulate AI processing
	time.Sleep(2 * time.Second)

	// Generate response (simulated)
	response := fmt.Sprintf("AI Response: I have processed the instruction '%s' using model %s",
		instruction, model)

	return executor.Success(map[string]any{
		"response":    response,
		"model":       model,
		"temperature": temperature,
		"tokensUsed":  150,
		"completedAt": time.Now().Format(time.RFC3339),
	}), nil
}

func (e *AIAgentExecutor) Metadata() executor.ExecutorMetadata {
	return executor.ExecutorMetadata{
		Type:          "ai-agent",
		Version:       "1.0.0",
		Capabilities:  []string{"ai", "llm", "openai"},
		MaxConcurrent: 5,
	}
}

func (e *AIAgentExecutor) HealthCheck(ctx context.Context) error {
	return nil
}

// ============================================================================
// EXAMPLE 4: DATA TRANSFORMER EXECUTOR
// ============================================================================

// DataTransformerExecutor transforms data between formats
type DataTransformerExecutor struct {
	logger *zap.Logger
}

func NewDataTransformerExecutor(logger *zap.Logger) *DataTransformerExecutor {
	return &DataTransformerExecutor{
		logger: logger,
	}
}

func (e *DataTransformerExecutor) Execute(ctx context.Context, task *executor.Task) (*executor.Result, error) {
	e.logger.Info("Transforming data",
		zap.String("run_id", task.RunID),
		zap.String("node_id", task.NodeID),
	)

	// Get transformation type
	transformType, ok := task.Config["type"].(string)
	if !ok {
		transformType = "json"
	}

	// Get input data
	inputData, ok := task.Context["data"]
	if !ok {
		return executor.FailureWithCode("NO_DATA", "Input data is required"), nil
	}

	var transformed any
	var err error

	switch transformType {
	case "json":
		transformed, err = e.transformToJSON(inputData)
	case "csv":
		transformed, err = e.transformToCSV(inputData)
	case "xml":
		transformed, err = e.transformToXML(inputData)
	default:
		return executor.FailureWithCode("UNKNOWN_TYPE", fmt.Sprintf("Unknown transform type: %s", transformType)), nil
	}

	if err != nil {
		return executor.Failure(err), nil
	}

	return executor.Success(map[string]any{
		"transformed":   transformed,
		"type":          transformType,
		"transformedAt": time.Now().Format(time.RFC3339),
	}), nil
}

func (e *DataTransformerExecutor) transformToJSON(data any) (string, error) {
	bytes, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

func (e *DataTransformerExecutor) transformToCSV(data any) (string, error) {
	// Simplified CSV transformation
	return fmt.Sprintf("CSV representation of %v", data), nil
}

func (e *DataTransformerExecutor) transformToXML(data any) (string, error) {
	// Simplified XML transformation
	return fmt.Sprintf("<data>%v</data>", data), nil
}

func (e *DataTransformerExecutor) Metadata() executor.ExecutorMetadata {
	return executor.ExecutorMetadata{
		Type:          "data-transformer",
		Version:       "1.0.0",
		Capabilities:  []string{"transform", "json", "csv", "xml"},
		MaxConcurrent: 15,
	}
}

func (e *DataTransformerExecutor) HealthCheck(ctx context.Context) error {
	return nil
}

// ============================================================================
// MAIN - RUN MULTIPLE EXECUTORS
// ============================================================================

func main() {
	// Initialize logger
	logger, _ := zap.NewProduction()
	defer logger.Sync()

	// Get engine endpoint from environment
	engineEndpoint := os.Getenv("golek_ENGINE_ENDPOINT")
	if engineEndpoint == "" {
		engineEndpoint = "localhost:9090"
	}

	// Create configuration
	config := executor.DefaultRuntimeConfig()
	config.EngineEndpoint = engineEndpoint

	// Determine which executor to run
	executorType := os.Getenv("EXECUTOR_TYPE")
	if executorType == "" {
		executorType = "order-validator"
	}

	var exec executor.Executor

	switch executorType {
	case "order-validator":
		exec = NewOrderValidatorExecutor(logger)
	case "payment-processor":
		exec = NewPaymentProcessorExecutor(logger)
	case "ai-agent":
		exec = NewAIAgentExecutor(logger)
	case "data-transformer":
		exec = NewDataTransformerExecutor(logger)
	default:
		logger.Fatal("Unknown executor type", zap.String("type", executorType))
	}

	// Create runtime
	runtime := executor.NewRuntime(exec, config, logger)

	// Start runtime
	ctx := context.Background()
	if err := runtime.Start(ctx); err != nil {
		logger.Fatal("Failed to start runtime", zap.Error(err))
	}

	logger.Info("Executor running",
		zap.String("type", exec.Metadata().Type),
		zap.String("version", exec.Metadata().Version),
	)

	// Wait for interrupt signal
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	<-sigChan

	logger.Info("Shutdown signal received")

	// Graceful shutdown
	if err := runtime.Stop(ctx); err != nil {
		logger.Error("Error during shutdown", zap.Error(err))
	}

	logger.Info("Executor stopped")
}

// ============================================================================
// DOCKER COMPOSE EXAMPLE
// ============================================================================

/*
version: '3.8'

services:
  # golek Engine
  golek-engine:
    image: golek/engine:latest
    ports:
      - "8080:8080"  # REST API
      - "9090:9090"  # gRPC
    environment:
      - DATABASE_URL=postgres://golek:password@postgres:5432/golek
      - KAFKA_BROKERS=kafka:9092
    depends_on:
      - postgres
      - kafka

  # Executors
  order-validator:
    image: golek/executor:latest
    environment:
      - EXECUTOR_TYPE=order-validator
      - golek_ENGINE_ENDPOINT=golek-engine:9090
    deploy:
      replicas: 3

  payment-processor:
    image: golek/executor:latest
    environment:
      - EXECUTOR_TYPE=payment-processor
      - golek_ENGINE_ENDPOINT=golek-engine:9090
    deploy:
      replicas: 2

  ai-agent:
    image: golek/executor:latest
    environment:
      - EXECUTOR_TYPE=ai-agent
      - golek_ENGINE_ENDPOINT=golek-engine:9090
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    deploy:
      replicas: 1

  # Infrastructure
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=golek
      - POSTGRES_USER=golek
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
    depends_on:
      - zookeeper

  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      - ZOOKEEPER_CLIENT_PORT=2181

volumes:
  postgres_data:
*/
