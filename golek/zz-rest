// Package rest provides REST API implementation
package rest

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"go.uber.org/zap"

	"tech.kayys.golek/pkg/core"
	"tech.kayys.golek/pkg/engine"
	"tech.kayys.golek/pkg/enterprise"
)

// ============================================================================
// REST API SERVER
// ============================================================================

// Server provides REST API for golek workflow engine
type Server struct {
	engine    core.WorkflowEngine
	security  *enterprise.AdvancedSecurityPlugin
	observability *enterprise.AdvancedObservabilityPlugin
	logger    *zap.Logger
	router    *mux.Router
}

// NewServer creates a new REST API server
func NewServer(
	engine core.WorkflowEngine,
	security *enterprise.AdvancedSecurityPlugin,
	observability *enterprise.AdvancedObservabilityPlugin,
	logger *zap.Logger,
) *Server {
	server := &Server{
		engine:        engine,
		security:      security,
		observability: observability,
		logger:        logger,
		router:        mux.NewRouter(),
	}
	
	server.registerRoutes()
	
	return server
}

// ServeHTTP implements http.Handler
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.router.ServeHTTP(w, r)
}

// registerRoutes registers all API routes
func (s *Server) registerRoutes() {
	api := s.router.PathPrefix("/api/v1").Subrouter()
	
	// Apply middleware
	api.Use(s.loggingMiddleware)
	api.Use(s.corsMiddleware)
	api.Use(s.authenticationMiddleware)
	api.Use(s.rateLimitMiddleware)
	
	// Health endpoints
	s.router.HandleFunc("/health", s.healthCheck).Methods("GET")
	s.router.HandleFunc("/ready", s.readinessCheck).Methods("GET")
	
	// Workflow Run endpoints
	runs := api.PathPrefix("/runs").Subrouter()
	runs.HandleFunc("", s.createRun).Methods("POST")
	runs.HandleFunc("/{runId}", s.getRun).Methods("GET")
	runs.HandleFunc("/{runId}/start", s.startRun).Methods("POST")
	runs.HandleFunc("/{runId}/suspend", s.suspendRun).Methods("POST")
	runs.HandleFunc("/{runId}/resume", s.resumeRun).Methods("POST")
	runs.HandleFunc("/{runId}/cancel", s.cancelRun).Methods("POST")
	runs.HandleFunc("/{runId}/signal", s.signalRun).Methods("POST")
	runs.HandleFunc("/{runId}/history", s.getExecutionHistory).Methods("GET")
	runs.HandleFunc("", s.queryRuns).Methods("GET")
	runs.HandleFunc("/active/count", s.getActiveRunsCount).Methods("GET")
	
	// Workflow Definition endpoints
	defs := api.PathPrefix("/definitions").Subrouter()
	defs.HandleFunc("", s.createDefinition).Methods("POST")
	defs.HandleFunc("/{definitionId}", s.getDefinition).Methods("GET")
	defs.HandleFunc("/{definitionId}", s.updateDefinition).Methods("PUT")
	defs.HandleFunc("/{definitionId}", s.deleteDefinition).Methods("DELETE")
	defs.HandleFunc("", s.listDefinitions).Methods("GET")
	
	// SAGA endpoints
	sagas := api.PathPrefix("/sagas").Subrouter()
	sagas.HandleFunc("", s.createSAGA).Methods("POST")
	sagas.HandleFunc("/{sagaId}/execute", s.executeSAGA).Methods("POST")
	
	// Audit endpoints
	audit := api.PathPrefix("/audit").Subrouter()
	audit.HandleFunc("/events", s.queryAuditEvents).Methods("GET")
}

// ============================================================================
// MIDDLEWARE
// ============================================================================

func (s *Server) loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		
		// Wrap response writer to capture status code
		wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
		
		next.ServeHTTP(wrapped, r)
		
		duration := time.Since(start)
		
		s.logger.Info("HTTP request",
			zap.String("method", r.Method),
			zap.String("path", r.URL.Path),
			zap.Int("status", wrapped.statusCode),
			zap.Duration("duration", duration),
		)
	})
}

func (s *Server) corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Tenant-ID")
		
		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

func (s *Server) authenticationMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Skip auth for health checks
		if r.URL.Path == "/health" || r.URL.Path == "/ready" {
			next.ServeHTTP(w, r)
			return
		}
		
		// Extract token from Authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			s.respondError(w, http.StatusUnauthorized, "missing authorization header")
			return
		}
		
		// Validate token
		tokenString := authHeader[7:] // Remove "Bearer " prefix
		claims, err := s.security.ValidateToken(tokenString)
		if err != nil {
			s.respondError(w, http.StatusUnauthorized, "invalid token")
			return
		}
		
		// Add claims to context
		ctx := context.WithValue(r.Context(), "claims", claims)
		next.ServeHTTP(w, r.WithContext(ctx))
		
		// Audit log
		s.security.AuditLog(enterprise.AuditEvent{
			TenantID:  claims.TenantID,
			UserID:    claims.UserID,
			Action:    r.Method,
			Resource:  r.URL.Path,
			Result:    "success",
			IPAddress: r.RemoteAddr,
		})
	})
}

func (s *Server) rateLimitMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get rate limit key (tenant ID or IP)
		key := r.Header.Get("X-Tenant-ID")
		if key == "" {
			key = r.RemoteAddr
		}
		
		if !s.security.CheckRateLimit(key) {
			s.respondError(w, http.StatusTooManyRequests, "rate limit exceeded")
			return
		}
		
		next.ServeHTTP(w, r)
	})
}

// ============================================================================
// WORKFLOW RUN HANDLERS
// ============================================================================

func (s *Server) createRun(w http.ResponseWriter, r *http.Request) {
	var req CreateRunRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	
	claims := s.getClaims(r)
	
	// Authorize
	if err := s.security.Authorize(claims, "workflow", "create"); err != nil {
		s.respondError(w, http.StatusForbidden, err.Error())
		return
	}
	
	// Create run
	createReq := &core.CreateRunRequest{
		DefinitionID: core.WorkflowDefinitionID(req.DefinitionID),
		TenantID:     claims.TenantID,
		Inputs:       req.Inputs,
		Labels:       req.Labels,
	}
	
	run, err := s.engine.CreateRun(r.Context(), createReq)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	// Record metrics
	s.observability.RecordWorkflowStarted(claims.TenantID, run.DefinitionID)
	
	s.respondJSON(w, http.StatusCreated, toRunResponse(run))
}

func (s *Server) getRun(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	claims := s.getClaims(r)
	
	run, err := s.engine.GetRun(r.Context(), runID, claims.TenantID)
	if err != nil {
		s.respondError(w, http.StatusNotFound, "workflow run not found")
		return
	}
	
	s.respondJSON(w, http.StatusOK, toRunResponse(run))
}

func (s *Server) startRun(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	claims := s.getClaims(r)
	
	if err := s.security.Authorize(claims, "workflow", "execute"); err != nil {
		s.respondError(w, http.StatusForbidden, err.Error())
		return
	}
	
	run, err := s.engine.StartRun(r.Context(), runID, claims.TenantID)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, toRunResponse(run))
}

func (s *Server) suspendRun(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	var req SuspendRunRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	
	claims := s.getClaims(r)
	
	run, err := s.engine.SuspendRun(r.Context(), runID, claims.TenantID, req.Reason)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, toRunResponse(run))
}

func (s *Server) resumeRun(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	var req ResumeRunRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	
	claims := s.getClaims(r)
	
	run, err := s.engine.ResumeRun(r.Context(), runID, claims.TenantID, req.ResumeData)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, toRunResponse(run))
}

func (s *Server) cancelRun(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	var req CancelRunRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	
	claims := s.getClaims(r)
	
	if err := s.engine.CancelRun(r.Context(), runID, claims.TenantID, req.Reason); err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, map[string]string{"status": "cancelled"})
}

func (s *Server) signalRun(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	var req SignalRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	
	signal := &core.Signal{
		Name:         req.SignalName,
		TargetNodeID: core.NodeID(req.TargetNodeID),
		Payload:      req.Payload,
		Timestamp:    time.Now(),
	}
	
	if err := s.engine.Signal(r.Context(), runID, signal); err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, map[string]string{"status": "signal sent"})
}

func (s *Server) getExecutionHistory(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	runID := core.WorkflowRunID(vars["runId"])
	
	claims := s.getClaims(r)
	
	events, err := s.engine.GetExecutionHistory(r.Context(), runID, claims.TenantID)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, map[string]any{
		"run_id":       runID,
		"total_events": len(events),
		"events":       events,
	})
}

func (s *Server) queryRuns(w http.ResponseWriter, r *http.Request) {
	claims := s.getClaims(r)
	
	// Parse query parameters
	query := &core.RunQuery{
		TenantID: claims.TenantID,
		Limit:    20,
		Offset:   0,
	}
	
	runs, err := s.engine.QueryRuns(r.Context(), query)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	response := make([]RunResponse, len(runs))
	for i, run := range runs {
		response[i] = toRunResponse(run)
	}
	
	s.respondJSON(w, http.StatusOK, response)
}

func (s *Server) getActiveRunsCount(w http.ResponseWriter, r *http.Request) {
	claims := s.getClaims(r)
	
	count, err := s.engine.GetActiveRunsCount(r.Context(), claims.TenantID)
	if err != nil {
		s.respondError(w, http.StatusInternalServerError, err.Error())
		return
	}
	
	s.respondJSON(w, http.StatusOK, map[string]int64{"count": count})
}

// ============================================================================
// WORKFLOW DEFINITION HANDLERS
// ============================================================================

func (s *Server) createDefinition(w http.ResponseWriter, r *http.Request) {
	// Implementation similar to createRun
	s.respondJSON(w, http.StatusCreated, map[string]string{"status": "created"})
}

func (s *Server) getDefinition(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, map[string]string{"status": "ok"})
}

func (s *Server) updateDefinition(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, map[string]string{"status": "updated"})
}

func (s *Server) deleteDefinition(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, map[string]string{"status": "deleted"})
}

func (s *Server) listDefinitions(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, []map[string]string{})
}

// ============================================================================
// SAGA HANDLERS
// ============================================================================

func (s *Server) createSAGA(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusCreated, map[string]string{"status": "created"})
}

func (s *Server) executeSAGA(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, map[string]string{"status": "executing"})
}

// ============================================================================
// AUDIT HANDLERS
// ============================================================================

func (s *Server) queryAuditEvents(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, []enterprise.AuditEvent{})
}

// ============================================================================
// HEALTH CHECKS
// ============================================================================

func (s *Server) healthCheck(w http.ResponseWriter, r *http.Request) {
	s.respondJSON(w, http.StatusOK, map[string]string{
		"status": "healthy",
		"time":   time.Now().Format(time.RFC3339),
	})
}

func (s *Server) readinessCheck(w http.ResponseWriter, r *http.Request) {
	// Check if engine is ready
	s.respondJSON(w, http.StatusOK, map[string]string{
		"status": "ready",
		"time":   time.Now().Format(time.RFC3339),
	})
}

// ============================================================================
// HELPER METHODS
// ============================================================================

func (s *Server) respondJSON(w http.ResponseWriter, status int, data any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(data)
}

func (s *Server) respondError(w http.ResponseWriter, status int, message string) {
	s.respondJSON(w, status, map[string]string{"error": message})
}

func (s *Server) getClaims(r *http.Request) *enterprise.TokenClaims {
	return r.Context().Value("claims").(*enterprise.TokenClaims)
}

func toRunResponse(run *core.WorkflowRun) RunResponse {
	return RunResponse{
		RunID:        run.ID.String(),
		TenantID:     run.TenantID.String(),
		DefinitionID: run.DefinitionID.String(),
		Status:       string(run.Status),
		CreatedAt:    run.CreatedAt,
	}
}

// ============================================================================
// REQUEST/RESPONSE MODELS
// ============================================================================

type CreateRunRequest struct {
	DefinitionID string         `json:"definition_id"`
	Inputs       map[string]any `json:"inputs,omitempty"`
	Labels       map[string]string `json:"labels,omitempty"`
}

type RunResponse struct {
	RunID        string    `json:"run_id"`
	TenantID     string    `json:"tenant_id"`
	DefinitionID string    `json:"definition_id"`
	Status       string    `json:"status"`
	CreatedAt    time.Time `json:"created_at"`
}

type SuspendRunRequest struct {
	Reason string `json:"reason"`
}

type ResumeRunRequest struct {
	ResumeData map[string]any `json:"resume_data"`
}

type CancelRunRequest struct {
	Reason string `json:"reason"`
}

type SignalRequest struct {
	SignalName   string         `json:"signal_name"`
	TargetNodeID string         `json:"target_node_id,omitempty"`
	Payload      map[string]any `json:"payload,omitempty"`
}

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}