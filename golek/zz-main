// Package main is the entry point for the golek workflow engine service
package main

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"gopkg.in/yaml.v3"

	"tech.kayys.golek/pkg/api/grpc"
	"tech.kayys.golek/pkg/api/rest"
	"tech.kayys.golek/pkg/core"
	"tech.kayys.golek/pkg/engine"
	"tech.kayys.golek/pkg/messaging/kafka"
	"tech.kayys.golek/pkg/plugins"
	"tech.kayys.golek/pkg/storage/postgres"
)

// ============================================================================
// CONFIGURATION
// ============================================================================

// Config represents the complete service configuration
type Config struct {
	Server        ServerConfig         `yaml:"server"`
	Database      DatabaseConfig       `yaml:"database"`
	Messaging     MessagingConfig      `yaml:"messaging"`
	Engine        EngineConfig         `yaml:"engine"`
	Security      SecurityConfig       `yaml:"security"`
	Plugins       plugins.PluginConfig `yaml:"plugins"`
	Observability ObservabilityConfig  `yaml:"observability"`
}

type ServerConfig struct {
	// REST API
	RESTEnabled bool `yaml:"rest_enabled"`
	RESTPort    int  `yaml:"rest_port"`

	// gRPC API
	GRPCEnabled bool `yaml:"grpc_enabled"`
	GRPCPort    int  `yaml:"grpc_port"`

	// GraphQL API
	GraphQLEnabled bool `yaml:"graphql_enabled"`
	GraphQLPort    int  `yaml:"graphql_port"`
}

type DatabaseConfig struct {
	Type            string `yaml:"type"` // postgres, mysql, mongodb
	Host            string `yaml:"host"`
	Port            int    `yaml:"port"`
	Database        string `yaml:"database"`
	Username        string `yaml:"username"`
	Password        string `yaml:"password"`
	MaxConnections  int    `yaml:"max_connections"`
	MaxIdleConns    int    `yaml:"max_idle_conns"`
	ConnMaxLifetime int    `yaml:"conn_max_lifetime"` // seconds
	SSLMode         string `yaml:"ssl_mode"`
}

type MessagingConfig struct {
	Type    string   `yaml:"type"` // kafka, nats, rabbitmq
	Brokers []string `yaml:"brokers"`
	Topic   string   `yaml:"topic"`
	GroupID string   `yaml:"group_id"`
}

type EngineConfig struct {
	MaxConcurrentRuns    int  `yaml:"max_concurrent_runs"`
	NodeExecutionTimeout int  `yaml:"node_execution_timeout"` // seconds
	EnableEventSourcing  bool `yaml:"enable_event_sourcing"`
	EnableCompensation   bool `yaml:"enable_compensation"`
}

type SecurityConfig struct {
	Enabled          bool     `yaml:"enabled"`
	JWTSecret        string   `yaml:"jwt_secret"`
	TokenExpiry      int      `yaml:"token_expiry"` // hours
	RequireTLS       bool     `yaml:"require_tls"`
	AllowedOrigins   []string `yaml:"allowed_origins"`
	RateLimitEnabled bool     `yaml:"rate_limit_enabled"`
	RateLimitRPS     int      `yaml:"rate_limit_rps"`
}

type ObservabilityConfig struct {
	MetricsEnabled  bool   `yaml:"metrics_enabled"`
	MetricsPort     int    `yaml:"metrics_port"`
	TracingEnabled  bool   `yaml:"tracing_enabled"`
	TracingEndpoint string `yaml:"tracing_endpoint"`
	LogLevel        string `yaml:"log_level"`
}

// LoadConfig loads configuration from file
func LoadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse config: %w", err)
	}

	// Apply environment variable overrides
	applyEnvOverrides(&config)

	return &config, nil
}

// applyEnvOverrides applies environment variable overrides
func applyEnvOverrides(config *Config) {
	if dbHost := os.Getenv("DATABASE_HOST"); dbHost != "" {
		config.Database.Host = dbHost
	}
	if dbPassword := os.Getenv("DATABASE_PASSWORD"); dbPassword != "" {
		config.Database.Password = dbPassword
	}
	if kafkaBrokers := os.Getenv("KAFKA_BROKERS"); kafkaBrokers != "" {
		config.Messaging.Brokers = []string{kafkaBrokers}
	}
	if jwtSecret := os.Getenv("JWT_SECRET"); jwtSecret != "" {
		config.Security.JWTSecret = jwtSecret
	}
}

// DefaultConfig provides default configuration
func DefaultConfig() *Config {
	return &Config{
		Server: ServerConfig{
			RESTEnabled:    true,
			RESTPort:       8080,
			GRPCEnabled:    true,
			GRPCPort:       9090,
			GraphQLEnabled: false,
			GraphQLPort:    8081,
		},
		Database: DatabaseConfig{
			Type:            "postgres",
			Host:            "localhost",
			Port:            5432,
			Database:        "golek",
			Username:        "golek",
			MaxConnections:  25,
			MaxIdleConns:    5,
			ConnMaxLifetime: 300,
			SSLMode:         "disable",
		},
		Messaging: MessagingConfig{
			Type:    "kafka",
			Brokers: []string{"localhost:9092"},
			Topic:   "golek-events",
			GroupID: "golek-engine",
		},
		Engine: EngineConfig{
			MaxConcurrentRuns:    1000,
			NodeExecutionTimeout: 300,
			EnableEventSourcing:  true,
			EnableCompensation:   true,
		},
		Security: SecurityConfig{
			Enabled:          true,
			TokenExpiry:      24,
			RequireTLS:       false,
			RateLimitEnabled: true,
			RateLimitRPS:     100,
		},
		Observability: ObservabilityConfig{
			MetricsEnabled: true,
			MetricsPort:    9090,
			TracingEnabled: true,
			LogLevel:       "info",
		},
	}
}

// ============================================================================
// APPLICATION
// ============================================================================

// Application represents the main application
type Application struct {
	config          *Config
	logger          *zap.Logger
	engine          *engine.DefaultWorkflowEngine
	pluginRegistry  *plugins.DefaultPluginRegistry
	restServer      *http.Server
	grpcServer      *grpc.Server
	shutdownTimeout time.Duration
}

// NewApplication creates a new application instance
func NewApplication(config *Config) (*Application, error) {
	// Initialize logger
	logConfig := zap.NewProductionConfig()
	logConfig.Level.UnmarshalText([]byte(config.Observability.LogLevel))
	logger, err := logConfig.Build()
	if err != nil {
		return nil, fmt.Errorf("failed to initialize logger: %w", err)
	}

	return &Application{
		config:          config,
		logger:          logger,
		shutdownTimeout: 30 * time.Second,
	}, nil
}

// Initialize initializes all application components
func (app *Application) Initialize(ctx context.Context) error {
	app.logger.Info("Initializing golek workflow engine",
		zap.String("version", "1.0.0"),
	)

	// Initialize plugin registry
	app.pluginRegistry = plugins.NewPluginRegistry(app.logger)

	// Load plugins
	if err := app.loadPlugins(); err != nil {
		return fmt.Errorf("failed to load plugins: %w", err)
	}

	// Initialize storage
	storage, err := app.initializeStorage()
	if err != nil {
		return fmt.Errorf("failed to initialize storage: %w", err)
	}

	// Initialize messaging
	messaging, err := app.initializeMessaging()
	if err != nil {
		return fmt.Errorf("failed to initialize messaging: %w", err)
	}

	// Initialize workflow engine
	app.engine = engine.NewWorkflowEngine(
		storage.DefinitionRepo,
		storage.RunRepo,
		storage.EventStore,
		storage.ExecutorRegistry,
		messaging.Scheduler,
		storage.LockManager,
		app.logger,
	)

	app.logger.Info("Application initialized successfully")

	return nil
}

// Start starts all application services
func (app *Application) Start(ctx context.Context) error {
	app.logger.Info("Starting golek workflow engine")

	// Start plugins
	if err := app.pluginRegistry.StartAll(ctx); err != nil {
		return fmt.Errorf("failed to start plugins: %w", err)
	}

	// Start REST API if enabled
	if app.config.Server.RESTEnabled {
		if err := app.startRESTServer(); err != nil {
			return fmt.Errorf("failed to start REST server: %w", err)
		}
	}

	// Start gRPC API if enabled
	if app.config.Server.GRPCEnabled {
		if err := app.startGRPCServer(); err != nil {
			return fmt.Errorf("failed to start gRPC server: %w", err)
		}
	}

	// Start metrics server if enabled
	if app.config.Observability.MetricsEnabled {
		app.startMetricsServer()
	}

	app.logger.Info("Application started successfully",
		zap.Int("rest_port", app.config.Server.RESTPort),
		zap.Int("grpc_port", app.config.Server.GRPCPort),
	)

	return nil
}

// Stop gracefully stops the application
func (app *Application) Stop(ctx context.Context) error {
	app.logger.Info("Stopping application")

	// Create shutdown context
	shutdownCtx, cancel := context.WithTimeout(context.Background(), app.shutdownTimeout)
	defer cancel()

	// Stop REST server
	if app.restServer != nil {
		if err := app.restServer.Shutdown(shutdownCtx); err != nil {
			app.logger.Error("Error stopping REST server", zap.Error(err))
		}
	}

	// Stop gRPC server
	if app.grpcServer != nil {
		app.grpcServer.GracefulStop()
	}

	// Stop plugins
	if err := app.pluginRegistry.StopAll(shutdownCtx); err != nil {
		app.logger.Error("Error stopping plugins", zap.Error(err))
	}

	app.logger.Info("Application stopped")

	return nil
}

// ============================================================================
// INITIALIZATION HELPERS
// ============================================================================

func (app *Application) loadPlugins() error {
	app.logger.Info("Loading plugins")

	loader := plugins.NewPluginLoader(app.pluginRegistry, app.logger)

	if err := loader.LoadFromConfig(&app.config.Plugins); err != nil {
		return err
	}

	return nil
}

func (app *Application) initializeStorage() (*Storage, error) {
	app.logger.Info("Initializing storage",
		zap.String("type", app.config.Database.Type),
	)

	switch app.config.Database.Type {
	case "postgres":
		return postgres.NewPostgresStorage(app.config.Database, app.logger)
	case "mysql":
		// return mysql.NewMySQLStorage(app.config.Database, app.logger)
		return nil, fmt.Errorf("MySQL not yet implemented")
	default:
		return nil, fmt.Errorf("unsupported database type: %s", app.config.Database.Type)
	}
}

func (app *Application) initializeMessaging() (*Messaging, error) {
	app.logger.Info("Initializing messaging",
		zap.String("type", app.config.Messaging.Type),
	)

	switch app.config.Messaging.Type {
	case "kafka":
		return kafka.NewKafkaMessaging(app.config.Messaging, app.logger)
	case "nats":
		// return nats.NewNATSMessaging(app.config.Messaging, app.logger)
		return nil, fmt.Errorf("NATS not yet implemented")
	default:
		return nil, fmt.Errorf("unsupported messaging type: %s", app.config.Messaging.Type)
	}
}

func (app *Application) startRESTServer() error {
	router := mux.NewRouter()

	// Register REST API routes
	rest.RegisterRoutes(router, app.engine, app.logger)

	// CORS middleware
	router.Use(corsMiddleware(app.config.Security.AllowedOrigins))

	// Rate limiting middleware
	if app.config.Security.RateLimitEnabled {
		router.Use(rateLimitMiddleware(app.config.Security.RateLimitRPS))
	}

	addr := fmt.Sprintf(":%d", app.config.Server.RESTPort)
	app.restServer = &http.Server{
		Addr:         addr,
		Handler:      router,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	go func() {
		app.logger.Info("REST API listening", zap.String("addr", addr))
		if err := app.restServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			app.logger.Fatal("REST server error", zap.Error(err))
		}
	}()

	return nil
}

func (app *Application) startGRPCServer() error {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", app.config.Server.GRPCPort))
	if err != nil {
		return err
	}

	app.grpcServer = grpc.NewServer()

	// Register gRPC services
	grpc.RegisterServices(app.grpcServer, app.engine, app.logger)

	go func() {
		app.logger.Info("gRPC API listening", zap.Int("port", app.config.Server.GRPCPort))
		if err := app.grpcServer.Serve(lis); err != nil {
			app.logger.Fatal("gRPC server error", zap.Error(err))
		}
	}()

	return nil
}

func (app *Application) startMetricsServer() {
	// Start Prometheus metrics server
	// Implementation would go here
}

// ============================================================================
// MIDDLEWARE
// ============================================================================

func corsMiddleware(allowedOrigins []string) mux.MiddlewareFunc {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			origin := r.Header.Get("Origin")

			// Check if origin is allowed
			allowed := false
			for _, ao := range allowedOrigins {
				if ao == "*" || ao == origin {
					allowed = true
					break
				}
			}

			if allowed {
				w.Header().Set("Access-Control-Allow-Origin", origin)
				w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Tenant-ID")
			}

			if r.Method == "OPTIONS" {
				w.WriteHeader(http.StatusOK)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

func rateLimitMiddleware(rps int) mux.MiddlewareFunc {
	// Simple rate limiting implementation
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Rate limiting logic would go here
			next.ServeHTTP(w, r)
		})
	}
}

// ============================================================================
// STORAGE AND MESSAGING INTERFACES
// ============================================================================

type Storage struct {
	DefinitionRepo   core.WorkflowDefinitionRepository
	RunRepo          core.WorkflowRunRepository
	EventStore       core.EventStore
	ExecutorRegistry core.ExecutorRegistry
	LockManager      engine.DistributedLockManager
}

type Messaging struct {
	Scheduler engine.Scheduler
}

// ============================================================================
// MAIN
// ============================================================================

func main() {
	// Load configuration
	configPath := os.Getenv("CONFIG_PATH")
	if configPath == "" {
		configPath = "config.yaml"
	}

	var config *Config
	var err error

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		// Use default config if file doesn't exist
		config = DefaultConfig()
	} else {
		config, err = LoadConfig(configPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to load config: %v\n", err)
			os.Exit(1)
		}
	}

	// Create application
	app, err := NewApplication(config)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create application: %v\n", err)
		os.Exit(1)
	}
	defer app.logger.Sync()

	// Initialize application
	ctx := context.Background()
	if err := app.Initialize(ctx); err != nil {
		app.logger.Fatal("Failed to initialize application", zap.Error(err))
	}

	// Start application
	if err := app.Start(ctx); err != nil {
		app.logger.Fatal("Failed to start application", zap.Error(err))
	}

	// Wait for interrupt signal
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	<-sigChan

	app.logger.Info("Shutdown signal received")

	// Graceful shutdown
	if err := app.Stop(ctx); err != nil {
		app.logger.Error("Error during shutdown", zap.Error(err))
	}

	app.logger.Info("golek workflow engine stopped")
}

// ============================================================================
// EXAMPLE CONFIG.YAML
// ============================================================================

/*
server:
  rest_enabled: true
  rest_port: 8080
  grpc_enabled: true
  grpc_port: 9090
  graphql_enabled: false

database:
  type: postgres
  host: localhost
  port: 5432
  database: golek
  username: golek
  password: password
  max_connections: 25
  max_idle_conns: 5
  conn_max_lifetime: 300
  ssl_mode: disable

messaging:
  type: kafka
  brokers:
    - localhost:9092
  topic: golek-events
  group_id: golek-engine

engine:
  max_concurrent_runs: 1000
  node_execution_timeout: 300
  enable_event_sourcing: true
  enable_compensation: true

security:
  enabled: true
  jwt_secret: "your-secret-key-min-32-chars-long"
  token_expiry: 24
  require_tls: false
  allowed_origins:
    - "*"
  rate_limit_enabled: true
  rate_limit_rps: 100

observability:
  metrics_enabled: true
  metrics_port: 9090
  tracing_enabled: true
  tracing_endpoint: "localhost:4318"
  log_level: info

plugins:
  plugins:
    - name: security-plugin
      type: security
      version: 1.0.0
      enabled: true
      config:
        jwt_enabled: true

    - name: postgres-storage
      type: storage
      version: 1.0.0
      enabled: true

    - name: kafka-messaging
      type: messaging
      version: 1.0.0
      enabled: true
*/
