# Wayang Designer - Complete Implementation

## Overview

Wayang Designer is the visual workflow authoring service for the AI Agent platform. It provides a comprehensive API for creating, editing, validating, and managing agent workflows with real-time collaboration, autosave, version control, and deep integration with the platform's schema registry, plugin system, and validation engines.

## Architecture

```mermaid
flowchart TB
    subgraph Designer["Wayang Designer Service"]
        direction TB
        API["REST/GraphQL API Layer"]
        WS["WebSocket Manager (Real-time)"]
        
        subgraph Core["Core Services"]
            WorkspaceMgr["Workspace Manager"]
            WorkflowMgr["Workflow Manager"]
            NodeMgr["Node Manager"]
            EdgeMgr["Edge/Connection Manager"]
            LayoutMgr["Layout Manager"]
        end
        
        subgraph Validation["Validation Layer"]
            SchemaVal["Schema Validator"]
            TypeChecker["Type Checker"]
            CELValidator["CEL Expression Validator"]
            PolicyValidator["Policy Validator"]
            GraphValidator["Graph Validator"]
        end
        
        subgraph Collab["Collaboration"]
            LockMgr["Lock Manager"]
            ConflictResolver["Conflict Resolver"]
            ChangeTracker["Change Tracker"]
            DiffEngine["Diff Engine"]
        end
        
        subgraph Persistence["Persistence"]
            AutoSave["AutoSave Manager"]
            DraftMgr["Draft Manager"]
            Persistor["Database Adapter"]
        end
        
        subgraph Integration["External Integration"]
            SchemaClient["Schema Registry Client"]
            VersionClient["Version Service Client"]
            LinterClient["Linter Client"]
            PluginClient["Plugin Manager Client"]
            GuardrailClient["Guardrail Client"]
        end
    end
    
    API --> WorkspaceMgr
    API --> WorkflowMgr
    API --> NodeMgr
    API --> EdgeMgr
    WS --> LockMgr
    WS --> ChangeTracker
    
    WorkflowMgr --> SchemaVal
    NodeMgr --> TypeChecker
    EdgeMgr --> GraphValidator
    
    WorkflowMgr --> AutoSave
    WorkspaceMgr --> Persistor
    
    SchemaVal --> SchemaClient
    PolicyValidator --> GuardrailClient
```

## Project Structure

```
wayang-designer/
├── pom.xml
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── tech/
│   │   │       └── kayys/
│   │   │           └── wayang/
│   │   │               └── designer/
│   │   │                   ├── api/
│   │   │                   │   ├── rest/
│   │   │                   │   │   ├── WorkspaceResource.java
│   │   │                   │   │   ├── WorkflowResource.java
│   │   │                   │   │   ├── NodeResource.java
│   │   │                   │   │   ├── EdgeResource.java
│   │   │                   │   │   └── ValidationResource.java
│   │   │                   │   ├── graphql/
│   │   │                   │   │   ├── DesignerGraphQL.java
│   │   │                   │   │   └── GraphQLSchemas.java
│   │   │                   │   └── websocket/
│   │   │                   │       ├── CollaborationWebSocket.java
│   │   │                   │       └── ChangeStreamWebSocket.java
│   │   │                   ├── service/
│   │   │                   │   ├── WorkspaceService.java
│   │   │                   │   ├── WorkflowService.java
│   │   │                   │   ├── NodeService.java
│   │   │                   │   ├── EdgeService.java
│   │   │                   │   ├── LayoutService.java
│   │   │                   │   ├── ValidationService.java
│   │   │                   │   ├── AutoSaveService.java
│   │   │                   │   ├── DraftService.java
│   │   │                   │   └── CollaborationService.java
│   │   │                   ├── domain/
│   │   │                   │   ├── model/
│   │   │                   │   │   ├── Workspace.java
│   │   │                   │   │   ├── Workflow.java
│   │   │                   │   │   ├── Node.java
│   │   │                   │   │   ├── Edge.java
│   │   │                   │   │   ├── Layout.java
│   │   │                   │   │   ├── Draft.java
│   │   │                   │   │   └── ValidationResult.java
│   │   │                   │   ├── dto/
│   │   │                   │   │   ├── WorkspaceDTO.java
│   │   │                   │   │   ├── WorkflowDTO.java
│   │   │                   │   │   ├── NodeDTO.java
│   │   │                   │   │   ├── EdgeDTO.java
│   │   │                   │   │   └── ValidationDTO.java
│   │   │                   │   └── repository/
│   │   │                   │       ├── WorkspaceRepository.java
│   │   │                   │       ├── WorkflowRepository.java
│   │   │                   │       ├── NodeRepository.java
│   │   │                   │       ├── EdgeRepository.java
│   │   │                   │       └── DraftRepository.java
│   │   │                   ├── validation/
│   │   │                   │   ├── SchemaValidator.java
│   │   │                   │   ├── TypeValidator.java
│   │   │                   │   ├── CELValidator.java
│   │   │                   │   ├── PolicyValidator.java
│   │   │                   │   ├── GraphValidator.java
│   │   │                   │   └── CompositeValidator.java
│   │   │                   ├── collaboration/
│   │   │                   │   ├── LockManager.java
│   │   │                   │   ├── ConflictResolver.java
│   │   │                   │   ├── ChangeTracker.java
│   │   │                   │   └── DiffEngine.java
│   │   │                   ├── client/
│   │   │                   │   ├── SchemaRegistryClient.java
│   │   │                   │   ├── VersionServiceClient.java
│   │   │                   │   ├── LinterClient.java
│   │   │                   │   ├── PluginManagerClient.java
│   │   │                   │   └── GuardrailClient.java
│   │   │                   ├── audit/
│   │   │                   │   ├── AuditLogger.java
│   │   │                   │   └── AuditEvent.java
│   │   │                   ├── error/
│   │   │                   │   ├── DesignerException.java
│   │   │                   │   ├── ValidationException.java
│   │   │                   │   ├── ConflictException.java
│   │   │                   │   └── ErrorHandler.java
│   │   │                   └── config/
│   │   │                       ├── DesignerConfig.java
│   │   │                       ├── CacheConfig.java
│   │   │                       └── SecurityConfig.java
│   │   └── resources/
│   │       ├── application.yml
│   │       ├── application-dev.yml
│   │       ├── application-prod.yml
│   │       ├── db/
│   │       │   └── migration/
│   │       │       ├── V1__initial_schema.sql
│   │       │       ├── V2__add_drafts.sql
│   │       │       └── V3__add_audit.sql
│   │       └── graphql/
│   │           └── designer.graphqls
│   └── test/
│       └── java/
│           └── tech/
│               └── kayys/
│                   └── wayang/
│                       └── designer/
│                           ├── service/
│                           ├── validation/
│                           └── integration/
└── kubernetes/
    ├── deployment.yaml
    ├── service.yaml
    └── configmap.yaml
```

## Implementation

### 1. POM.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>tech.kayys.wayang</groupId>
    <artifactId>wayang-designer</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>Wayang Designer Service</name>
    <description>Visual workflow designer service for AI Agent platform</description>

    <properties>
        <quarkus.version>3.16.3</quarkus.version>
        <compiler-plugin.version>3.13.0</compiler-plugin.version>
        <maven.compiler.release>21</maven.compiler.release>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        
        <!-- Library versions -->
        <cel-java.version>0.4.4</cel-java.version>
        <jgrapht.version>1.5.2</jgrapht.version>
        <jackson.version>2.17.0</jackson.version>
        <lombok.version>1.18.34</lombok.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.quarkus.platform</groupId>
                <artifactId>quarkus-bom</artifactId>
                <version>${quarkus.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Quarkus Core -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-arc</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy-reactive-jackson</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-graphql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-websockets-next</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-orm-panache</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-jdbc-postgresql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-flyway</artifactId>
        </dependency>

        <!-- Cache -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-redis-cache</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-cache</artifactId>
        </dependency>

        <!-- Reactive & Messaging -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-reactive-messaging-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-reactive-messaging</artifactId>
        </dependency>

        <!-- Security -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-oidc</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-jwt</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-security</artifactId>
        </dependency>

        <!-- Observability -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-opentelemetry</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-micrometer-registry-prometheus</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-logging-json</artifactId>
        </dependency>

        <!-- Health & Metrics -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-health</artifactId>
        </dependency>

        <!-- Validation -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-validator</artifactId>
        </dependency>

        <!-- REST Client (for external services) -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-rest-client-reactive-jackson</artifactId>
        </dependency>

        <!-- Scheduler -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-scheduler</artifactId>
        </dependency>

        <!-- CEL (Common Expression Language) -->
        <dependency>
            <groupId>org.projectnessie.cel</groupId>
            <artifactId>cel-tools</artifactId>
            <version>${cel-java.version}</version>
        </dependency>

        <!-- Graph processing -->
        <dependency>
            <groupId>org.jgrapht</groupId>
            <artifactId>jgrapht-core</artifactId>
            <version>${jgrapht.version}</version>
        </dependency>

        <!-- Utilities -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-junit5</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-test-h2</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>io.quarkus.platform</groupId>
                <artifactId>quarkus-maven-plugin</artifactId>
                <version>${quarkus.version}</version>
                <extensions>true</extensions>
                <executions>
                    <execution>
                        <goals>
                            <goal>build</goal>
                            <goal>generate-code</goal>
                            <goal>generate-code-tests</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${compiler-plugin.version}</version>
                <configuration>
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.5</version>
                <configuration>
                    <systemPropertyVariables>
                        <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### 2. Application Configuration

**application.yml**

```yaml
# Wayang Designer Service Configuration

quarkus:
  application:
    name: wayang-designer
    version: ${project.version}

  # HTTP Configuration
  http:
    port: 8080
    cors:
      ~: true
      origins: "*"
      methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
      headers: "*"
    limits:
      max-body-size: 50M
    ssl:
      certificate:
        key-store-file: ${SSL_KEYSTORE:}
        key-store-password: ${SSL_KEYSTORE_PASSWORD:}

  # Database Configuration
  datasource:
    db-kind: postgresql
    username: ${DB_USERNAME:wayang}
    password: ${DB_PASSWORD:wayang}
    jdbc:
      url: ${DB_URL:jdbc:postgresql://localhost:5432/wayang_designer}
      max-size: 20
      min-size: 5
    reactive:
      url: ${DB_REACTIVE_URL:postgresql://localhost:5432/wayang_designer}

  hibernate-orm:
    database:
      generation: none
    log:
      sql: false
      bind-parameters: true
    jdbc:
      statement-batch-size: 50

  flyway:
    migrate-at-start: true
    locations: classpath:db/migration
    baseline-on-migrate: true

  # Cache Configuration
  redis:
    hosts: ${REDIS_URL:redis://localhost:6379}
    password: ${REDIS_PASSWORD:}
    client-type: standalone
    
  cache:
    redis:
      enabled: true
      ttl: 3600s

  # Messaging (Kafka)
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    security:
      protocol: ${KAFKA_SECURITY_PROTOCOL:PLAINTEXT}

  # GraphQL
  smallrye-graphql:
    ui:
      always-include: true
    print-data-fetcher-exception: true
    schema-include-scalars: true
    schema-include-directives: true

  # WebSocket
  websockets:
    max-message-size: 10M

  # Security
  oidc:
    auth-server-url: ${OIDC_SERVER_URL:http://localhost:8180/realms/wayang}
    client-id: ${OIDC_CLIENT_ID:wayang-designer}
    credentials:
      secret: ${OIDC_CLIENT_SECRET:}
    tls:
      verification: ${OIDC_TLS_VERIFY:none}

  smallrye-jwt:
    enabled: true

  security:
    users:
      embedded:
        enabled: false

  # OpenTelemetry
  otel:
    exporter:
      otlp:
        endpoint: ${OTEL_ENDPOINT:http://localhost:4317}
    traces:
      sampler: always_on
    metrics:
      exporter: prometheus

  # Health & Metrics
  smallrye-health:
    ui:
      always-include: true

  # Logging
  log:
    level: INFO
    category:
      "tech.kayys.wayang": DEBUG
      "io.quarkus": INFO
    console:
      json: ${LOG_JSON:false}

  # Scheduler
  scheduler:
    enabled: true

# Application Specific Configuration
wayang:
  designer:
    # Workspace limits
    workspace:
      max-per-tenant: 100
      max-workflows-per-workspace: 50

    # Workflow limits  
    workflow:
      max-nodes: 1000
      max-edges: 2000
      max-name-length: 255

    # Auto-save configuration
    autosave:
      enabled: true
      interval-seconds: 30
      max-drafts: 10

    # Collaboration
    collaboration:
      lock-timeout-seconds: 300
      max-concurrent-editors: 10

    # Validation
    validation:
      strict-mode: false
      async-validation: true
      validation-timeout-seconds: 30

    # Integration endpoints
    integration:
      schema-registry:
        url: ${SCHEMA_REGISTRY_URL:http://localhost:8081}
        timeout: 10s
      version-service:
        url: ${VERSION_SERVICE_URL:http://localhost:8082}
        timeout: 10s
      linter:
        url: ${LINTER_URL:http://localhost:8083}
        timeout: 30s
      plugin-manager:
        url: ${PLUGIN_MANAGER_URL:http://localhost:8084}
        timeout: 10s
      guardrail:
        url: ${GUARDRAIL_URL:http://localhost:8085}
        timeout: 15s

    # Audit
    audit:
      enabled: true
      kafka-topic: designer-audit-events
      async: true

# Profiles
"%dev":
  quarkus:
    log:
      level: DEBUG
      console:
        json: false
    hibernate-orm:
      log:
        sql: true

"%prod":
  quarkus:
    log:
      console:
        json: true
    hibernate-orm:
      log:
        sql: false
```

### 3. Domain Models

**Workspace.java**

```java
package tech.kayys.wayang.designer.domain.model;

import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Workspace entity - represents a project container for workflows
 * 
 * A workspace is the top-level organizational unit that contains multiple workflows.
 * It provides isolation boundaries for multi-tenant deployments and groups related
 * workflows together.
 */
@Entity
@Table(
    name = "workspaces",
    indexes = {
        @Index(name = "idx_workspace_tenant", columnList = "tenant_id"),
        @Index(name = "idx_workspace_owner", columnList = "owner_id"),
        @Index(name = "idx_workspace_status", columnList = "status")
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Workspace extends PanacheEntityBase {

    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotBlank(message = "Workspace name is required")
    @Size(max = 255, message = "Workspace name must not exceed 255 characters")
    @Column(name = "name", nullable = false)
    private String name;

    @Size(max = 1000, message = "Description must not exceed 1000 characters")
    @Column(name = "description", length = 1000)
    private String description;

    @NotNull(message = "Tenant ID is required")
    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @NotNull(message = "Owner ID is required")
    @Column(name = "owner_id", nullable = false)
    private String ownerId;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @Builder.Default
    private WorkspaceStatus status = WorkspaceStatus.ACTIVE;

    @Column(name = "tags", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private List<String> tags = new ArrayList<>();

    @Column(name = "metadata", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private WorkspaceMetadata metadata;

    @OneToMany(mappedBy = "workspace", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<Workflow> workflows = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @Column(name = "created_by", nullable = false, updatable = false)
    private String createdBy;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "updated_by")
    private String updatedBy;

    @Version
    @Column(name = "version")
    private Long version;

    public enum WorkspaceStatus {
        ACTIVE,
        ARCHIVED,
        DELETED
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class WorkspaceMetadata {
        private String icon;
        private String color;
        private Boolean favorite;
        private Integer workflowCount;
        private Instant lastAccessedAt;
    }

    // Helper methods
    public void addWorkflow(Workflow workflow) {
        workflows.add(workflow);
        workflow.setWorkspace(this);
    }

    public void removeWorkflow(Workflow workflow) {
        workflows.remove(workflow);
        workflow.setWorkspace(null);
    }
}
```

**Workflow.java**

```java
package tech.kayys.wayang.designer.domain.model;

import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Workflow entity - represents a complete agent workflow graph
 * 
 * Contains the entire workflow definition including nodes, edges, layout information,
 * and configuration. Supports versioning, validation state tracking, and publishing.
 */
@Entity
@Table(
    name = "workflows",
    indexes = {
        @Index(name = "idx_workflow_workspace", columnList = "workspace_id"),
        @Index(name = "idx_workflow_status", columnList = "status"),
        @Index(name = "idx_workflow_tenant", columnList = "tenant_id")
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Workflow extends PanacheEntityBase {

    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotBlank(message = "Workflow name is required")
    @Size(max = 255, message = "Workflow name must not exceed 255 characters")
    @Column(name = "name", nullable = false)
    private String name;

    @Size(max = 2000, message = "Description must not exceed 2000 characters")
    @Column(name = "description", length = 2000)
    private String description;

    @NotNull(message = "Workspace is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "workspace_id", nullable = false)
    private Workspace workspace;

    @NotNull(message = "Tenant ID is required")
    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @Builder.Default
    private WorkflowStatus status = WorkflowStatus.DRAFT;

    @OneToMany(mappedBy = "workflow", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<Node> nodes = new ArrayList<>();

    @OneToMany(mappedBy = "workflow", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<Edge> edges = new ArrayList<>();

    @OneToOne(mappedBy = "workflow", cascade = CascadeType.ALL, orphanRemoval = true)
    private Layout layout;

    @Column(name = "validation_state", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private ValidationState validationState;

    @Column(name = "configuration", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private WorkflowConfiguration configuration;

    @Column(name = "tags", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private List<String> tags = new ArrayList<>();

    @Column(name = "published_version")
    private String publishedVersion;

    @Column(name = "published_at")
    private Instant publishedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @Column(name = "created_by", nullable = false, updatable = false)
    private String createdBy;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "updated_by")
    private String updatedBy;

    @Version
    @Column(name = "version")
    private Long version;

    public enum WorkflowStatus {
        DRAFT,
        VALIDATING,
        VALID,
        INVALID,
        PUBLISHED,
        ARCHIVED,
        DELETED
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ValidationState {
        private Boolean isValid;
        private Instant lastValidatedAt;
        private List<ValidationError> errors;
        private List<ValidationWarning> warnings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ValidationError {
        private String code;
        private String message;
        private String nodeId;
        private String field;
        private String severity;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ValidationWarning {
        private String code;
        private String message;
        private String nodeId;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class WorkflowConfiguration {
        private Integer maxConcurrency;
        private Integer timeout;
        private String retryPolicy;
        private Boolean enableCheckpoints;
        private Boolean enableStreaming;
    }

    // Helper methods
    public void addNode(Node node) {
        nodes.add(node);
        node.setWorkflow(this);
    }

    public void removeNode(Node node) {
        nodes.remove(node);
        node.setWorkflow(null);
    }

    public void addEdge(Edge edge) {
        edges.add(edge);
        edge.setWorkflow(this);
    }

    public void removeEdge(Edge edge) {
        edges.remove(edge);
        edge.setWorkflow(null);
    }
}
```

**Node.java**

```java
package tech.kayys.wayang.designer.domain.model;

import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Node entity - represents a single node in a workflow
 * 
 * Each node represents an execution unit (agent, tool, decision, etc.) with its
 * configuration, inputs, outputs, and runtime properties. Nodes are typed and
 * must conform to their type's schema from the Node Registry.
 */
@Entity
@Table(
    name = "nodes",
    indexes = {
        @Index(name = "idx_node_workflow", columnList = "workflow_id"),
        @Index(name = "idx_node_type", columnList = "node_type"),
        @Index(name = "idx_node_tenant", columnList = "tenant_id")
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Node extends PanacheEntityBase {

    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotBlank(message = "Node ID is required")
    @Column(name = "node_id", nullable = false)
    private String nodeId; // User-friendly ID for referencing

    @NotBlank(message = "Node name is required")
    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "description", length = 1000)
    private String description;

    @NotNull(message = "Workflow is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "workflow_id", nullable = false)
    private Workflow workflow;

    @NotNull(message = "Tenant ID is required")
    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @NotBlank(message = "Node type is required")
    @Column(name = "node_type", nullable = false)
    private String nodeType; // References Node Registry

    @Column(name = "node_descriptor_version")
    private String nodeDescriptorVersion;

    @Column(name = "config", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private Map<String, Object> config = new HashMap<>();

    @Column(name = "inputs", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private Map<String, NodePort> inputs = new HashMap<>();

    @Column(name = "outputs", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private Map<String, NodePort> outputs = new HashMap<>();

    @Column(name = "properties", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private Map<String, Object> properties = new HashMap<>();

    @Column(name = "position", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private NodePosition position;

    @Column(name = "ui_metadata", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private NodeUIMetadata uiMetadata;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @Builder.Default
    private NodeStatus status = NodeStatus.ACTIVE;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Version
    @Column(name = "version")
    private Long version;

    public enum NodeStatus {
        ACTIVE,
        DISABLED,
        ERROR
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NodePort {
        private String name;
        private String type;
        private Boolean required;
        private Object defaultValue;
        private String description;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NodePosition {
        private Double x;
        private Double y;
        private Double width;
        private Double height;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class NodeUIMetadata {
        private String icon;
        private String color;
        private Boolean collapsed;
        private String layer;
    }
}
```

**Edge.java**

```java
package tech.kayys.wayang.designer.domain.model;

import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

/**
 * Edge entity - represents a connection between two nodes
 * 
 * Edges define the data flow and execution dependencies between nodes.
 * They specify which output port connects to which input port and can
 * include transformation logic or conditional routing.
 */
@Entity
@Table(
    name = "edges",
    indexes = {
        @Index(name = "idx_edge_workflow", columnList = "workflow_id"),
        @Index(name = "idx_edge_source", columnList = "source_node_id"),
        @Index(name = "idx_edge_target", columnList = "target_node_id")
    },
    uniqueConstraints = {
        @UniqueConstraint(
            name = "uk_edge_connection",
            columnNames = {"workflow_id", "source_node_id", "source_port", "target_node_id", "target_port"}
        )
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Edge extends PanacheEntityBase {

    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotBlank(message = "Edge ID is required")
    @Column(name = "edge_id", nullable = false)
    private String edgeId; // User-friendly ID

    @NotNull(message = "Workflow is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "workflow_id", nullable = false)
    private Workflow workflow;

    @NotBlank(message = "Source node ID is required")
    @Column(name = "source_node_id", nullable = false)
    private String sourceNodeId;

    @NotBlank(message = "Source port is required")
    @Column(name = "source_port", nullable = false)
    private String sourcePort;

    @NotBlank(message = "Target node ID is required")
    @Column(name = "target_node_id", nullable = false)
    private String targetNodeId;

    @NotBlank(message = "Target port is required")
    @Column(name = "target_port", nullable = false)
    private String targetPort;

    @Enumerated(EnumType.STRING)
    @Column(name = "edge_type")
    @Builder.Default
    private EdgeType edgeType = EdgeType.DATA;

    @Column(name = "condition")
    private String condition; // CEL expression for conditional routing

    @Column(name = "transformation")
    private String transformation; // CEL expression for data transformation

    @Column(name = "properties", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private Map<String, Object> properties;

    @Column(name = "ui_metadata", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private EdgeUIMetadata uiMetadata;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @Builder.Default
    private EdgeStatus status = EdgeStatus.ACTIVE;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Version
    @Column(name = "version")
    private Long version;

    public enum EdgeType {
        DATA,      // Normal data flow
        CONTROL,   // Control flow (execution order)
        ERROR,     // Error handling path
        FALLBACK   // Fallback path
    }

    public enum EdgeStatus {
        ACTIVE,
        DISABLED
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class EdgeUIMetadata {
        private String style; // solid, dashed, dotted
        private String color;
        private String label;
        private Boolean animated;
    }
}
```

**Layout.java**

```java
package tech.kayys.wayang.designer.domain.model;

import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Layout entity - stores visual layout information for a workflow
 * 
 * Contains canvas-specific metadata like zoom, pan position, viewport,
 * and other UI-related state that shouldn't be in the core workflow definition.
 */
@Entity
@Table(name = "layouts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Layout extends PanacheEntityBase {

    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "workflow_id", nullable = false, unique = true)
    private Workflow workflow;

    @Column(name = "viewport", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    private Viewport viewport;

    @Column(name = "minimap_enabled")
    @Builder.Default
    private Boolean minimapEnabled = true;

    @Column(name = "grid_enabled")
    @Builder.Default
    private Boolean gridEnabled = true;

    @Column(name = "snap_to_grid")
    @Builder.Default
    private Boolean snapToGrid = false;

    @Column(name = "settings", columnDefinition = "jsonb")
    @Convert(converter = JsonbConverter.class)
    @Builder.Default
    private Map<String, Object> settings = new HashMap<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Viewport {
        private Double x;
        private Double y;
        private Double zoom;
    }
}
```

**Draft.java**

```java
package tech.kayys.wayang.designer.domain.model;

import io.quarkus.hibernate.orm.panache.PanacheEntityBase;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.Instant;
import java.util.UUID;

/**
 * Draft entity - stores auto-saved workflow states
 * 
 * Drafts enable crash recovery and provide a history of changes before
 * explicit saves. They are automatically cleaned up after a certain period
 * or when the draft count exceeds limits.
 */
@Entity
@Table(
    name = "drafts",
    indexes = {
        @Index(name = "idx_draft_workflow", columnList = "workflow_id"),
        @Index(name = "idx_draft_created", columnList = "created_at")
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Draft extends PanacheEntityBase {

    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @Column(name = "workflow_id", nullable = false)
    private UUID workflowId;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @Column(name = "snapshot", columnDefinition = "jsonb", nullable = false)
    @Convert(converter = JsonbConverter.class)
    private WorkflowSnapshot snapshot;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @Column(name = "expires_at")
    private Instant expiresAt;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class WorkflowSnapshot {
        private String workflowId;
        private String name;
        private Object nodes;
        private Object edges;
        private Object layout;
        private Object configuration;
        private Long version;
    }
}
```

Continue with Part 2?

### 4. DTOs (Data Transfer Objects)

**WorkspaceDTO.java**

```java
package tech.kayys.wayang.designer.domain.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import tech.kayys.wayang.designer.domain.model.Workspace;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
 * Data Transfer Object for Workspace
 * 
 * Used for API requests/responses with appropriate validation and
 * serialization rules. Separated from domain model for clean API contracts.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class WorkspaceDTO {

    private UUID id;

    @NotBlank(message = "Workspace name is required")
    @Size(max = 255, message = "Workspace name must not exceed 255 characters")
    private String name;

    @Size(max = 1000, message = "Description must not exceed 1000 characters")
    private String description;

    private UUID tenantId;
    private String ownerId;
    private Workspace.WorkspaceStatus status;
    private List<String> tags;
    private MetadataDTO metadata;
    private Integer workflowCount;
    private Instant createdAt;
    private String createdBy;
    private Instant updatedAt;
    private String updatedBy;
    private Long version;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class MetadataDTO {
        private String icon;
        private String color;
        private Boolean favorite;
        private Instant lastAccessedAt;
    }

    // Factory methods for conversion
    public static WorkspaceDTO from(Workspace workspace) {
        if (workspace == null) return null;

        MetadataDTO metadataDTO = null;
        if (workspace.getMetadata() != null) {
            metadataDTO = MetadataDTO.builder()
                .icon(workspace.getMetadata().getIcon())
                .color(workspace.getMetadata().getColor())
                .favorite(workspace.getMetadata().getFavorite())
                .lastAccessedAt(workspace.getMetadata().getLastAccessedAt())
                .build();
        }

        return WorkspaceDTO.builder()
            .id(workspace.getId())
            .name(workspace.getName())
            .description(workspace.getDescription())
            .tenantId(workspace.getTenantId())
            .ownerId(workspace.getOwnerId())
            .status(workspace.getStatus())
            .tags(workspace.getTags())
            .metadata(metadataDTO)
            .workflowCount(workspace.getWorkflows() != null ? workspace.getWorkflows().size() : 0)
            .createdAt(workspace.getCreatedAt())
            .createdBy(workspace.getCreatedBy())
            .updatedAt(workspace.getUpdatedAt())
            .updatedBy(workspace.getUpdatedBy())
            .version(workspace.getVersion())
            .build();
    }

    public Workspace toEntity() {
        Workspace.WorkspaceMetadata entityMetadata = null;
        if (this.metadata != null) {
            entityMetadata = new Workspace.WorkspaceMetadata();
            entityMetadata.setIcon(this.metadata.getIcon());
            entityMetadata.setColor(this.metadata.getColor());
            entityMetadata.setFavorite(this.metadata.getFavorite());
            entityMetadata.setLastAccessedAt(this.metadata.getLastAccessedAt());
        }

        return Workspace.builder()
            .id(this.id)
            .name(this.name)
            .description(this.description)
            .tenantId(this.tenantId)
            .ownerId(this.ownerId)
            .status(this.status != null ? this.status : Workspace.WorkspaceStatus.ACTIVE)
            .tags(this.tags)
            .metadata(entityMetadata)
            .createdBy(this.createdBy)
            .updatedBy(this.updatedBy)
            .build();
    }
}
```

**WorkflowDTO.java**

```java
package tech.kayys.wayang.designer.domain.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import tech.kayys.wayang.designer.domain.model.Workflow;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
 * Data Transfer Object for Workflow
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class WorkflowDTO {

    private UUID id;

    @NotBlank(message = "Workflow name is required")
    @Size(max = 255, message = "Workflow name must not exceed 255 characters")
    private String name;

    @Size(max = 2000, message = "Description must not exceed 2000 characters")
    private String description;

    private UUID workspaceId;
    private UUID tenantId;
    private Workflow.WorkflowStatus status;
    private List<NodeDTO> nodes;
    private List<EdgeDTO> edges;
    private LayoutDTO layout;
    private ValidationStateDTO validationState;
    private ConfigurationDTO configuration;
    private List<String> tags;
    private String publishedVersion;
    private Instant publishedAt;
    private Instant createdAt;
    private String createdBy;
    private Instant updatedAt;
    private String updatedBy;
    private Long version;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class ValidationStateDTO {
        private Boolean isValid;
        private Instant lastValidatedAt;
        private List<ValidationErrorDTO> errors;
        private List<ValidationWarningDTO> warnings;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class ValidationErrorDTO {
        private String code;
        private String message;
        private String nodeId;
        private String field;
        private String severity;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class ValidationWarningDTO {
        private String code;
        private String message;
        private String nodeId;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class ConfigurationDTO {
        private Integer maxConcurrency;
        private Integer timeout;
        private String retryPolicy;
        private Boolean enableCheckpoints;
        private Boolean enableStreaming;
    }

    // Conversion methods
    public static WorkflowDTO from(Workflow workflow, boolean includeNodes) {
        if (workflow == null) return null;

        WorkflowDTOBuilder builder = WorkflowDTO.builder()
            .id(workflow.getId())
            .name(workflow.getName())
            .description(workflow.getDescription())
            .workspaceId(workflow.getWorkspace() != null ? workflow.getWorkspace().getId() : null)
            .tenantId(workflow.getTenantId())
            .status(workflow.getStatus())
            .tags(workflow.getTags())
            .publishedVersion(workflow.getPublishedVersion())
            .publishedAt(workflow.getPublishedAt())
            .createdAt(workflow.getCreatedAt())
            .createdBy(workflow.getCreatedBy())
            .updatedAt(workflow.getUpdatedAt())
            .updatedBy(workflow.getUpdatedBy())
            .version(workflow.getVersion());

        // Include nodes and edges if requested (can be expensive)
        if (includeNodes && workflow.getNodes() != null) {
            builder.nodes(workflow.getNodes().stream()
                .map(NodeDTO::from)
                .toList());
        }

        if (includeNodes && workflow.getEdges() != null) {
            builder.edges(workflow.getEdges().stream()
                .map(EdgeDTO::from)
                .toList());
        }

        if (workflow.getLayout() != null) {
            builder.layout(LayoutDTO.from(workflow.getLayout()));
        }

        // Validation state
        if (workflow.getValidationState() != null) {
            builder.validationState(convertValidationState(workflow.getValidationState()));
        }

        // Configuration
        if (workflow.getConfiguration() != null) {
            builder.configuration(convertConfiguration(workflow.getConfiguration()));
        }

        return builder.build();
    }

    private static ValidationStateDTO convertValidationState(Workflow.ValidationState state) {
        if (state == null) return null;

        List<ValidationErrorDTO> errors = null;
        if (state.getErrors() != null) {
            errors = state.getErrors().stream()
                .map(e -> ValidationErrorDTO.builder()
                    .code(e.getCode())
                    .message(e.getMessage())
                    .nodeId(e.getNodeId())
                    .field(e.getField())
                    .severity(e.getSeverity())
                    .build())
                .toList();
        }

        List<ValidationWarningDTO> warnings = null;
        if (state.getWarnings() != null) {
            warnings = state.getWarnings().stream()
                .map(w -> ValidationWarningDTO.builder()
                    .code(w.getCode())
                    .message(w.getMessage())
                    .nodeId(w.getNodeId())
                    .build())
                .toList();
        }

        return ValidationStateDTO.builder()
            .isValid(state.getIsValid())
            .lastValidatedAt(state.getLastValidatedAt())
            .errors(errors)
            .warnings(warnings)
            .build();
    }

    private static ConfigurationDTO convertConfiguration(Workflow.WorkflowConfiguration config) {
        if (config == null) return null;

        return ConfigurationDTO.builder()
            .maxConcurrency(config.getMaxConcurrency())
            .timeout(config.getTimeout())
            .retryPolicy(config.getRetryPolicy())
            .enableCheckpoints(config.getEnableCheckpoints())
            .enableStreaming(config.getEnableStreaming())
            .build();
    }
}
```

**NodeDTO.java**

```java
package tech.kayys.wayang.designer.domain.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import tech.kayys.wayang.designer.domain.model.Node;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

/**
 * Data Transfer Object for Node
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeDTO {

    private UUID id;

    @NotBlank(message = "Node ID is required")
    private String nodeId;

    @NotBlank(message = "Node name is required")
    private String name;

    private String description;

    @NotBlank(message = "Node type is required")
    private String nodeType;

    private String nodeDescriptorVersion;
    private Map<String, Object> config;
    private Map<String, Node.NodePort> inputs;
    private Map<String, Node.NodePort> outputs;
    private Map<String, Object> properties;
    private PositionDTO position;
    private UIMetadataDTO uiMetadata;
    private Node.NodeStatus status;
    private Instant createdAt;
    private Instant updatedAt;
    private Long version;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class PositionDTO {
        private Double x;
        private Double y;
        private Double width;
        private Double height;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class UIMetadataDTO {
        private String icon;
        private String color;
        private Boolean collapsed;
        private String layer;
    }

    public static NodeDTO from(Node node) {
        if (node == null) return null;

        PositionDTO positionDTO = null;
        if (node.getPosition() != null) {
            positionDTO = PositionDTO.builder()
                .x(node.getPosition().getX())
                .y(node.getPosition().getY())
                .width(node.getPosition().getWidth())
                .height(node.getPosition().getHeight())
                .build();
        }

        UIMetadataDTO uiMetadataDTO = null;
        if (node.getUiMetadata() != null) {
            uiMetadataDTO = UIMetadataDTO.builder()
                .icon(node.getUiMetadata().getIcon())
                .color(node.getUiMetadata().getColor())
                .collapsed(node.getUiMetadata().getCollapsed())
                .layer(node.getUiMetadata().getLayer())
                .build();
        }

        return NodeDTO.builder()
            .id(node.getId())
            .nodeId(node.getNodeId())
            .name(node.getName())
            .description(node.getDescription())
            .nodeType(node.getNodeType())
            .nodeDescriptorVersion(node.getNodeDescriptorVersion())
            .config(node.getConfig())
            .inputs(node.getInputs())
            .outputs(node.getOutputs())
            .properties(node.getProperties())
            .position(positionDTO)
            .uiMetadata(uiMetadataDTO)
            .status(node.getStatus())
            .createdAt(node.getCreatedAt())
            .updatedAt(node.getUpdatedAt())
            .version(node.getVersion())
            .build();
    }

    public Node toEntity() {
        Node.NodePosition entityPosition = null;
        if (this.position != null) {
            entityPosition = new Node.NodePosition();
            entityPosition.setX(this.position.getX());
            entityPosition.setY(this.position.getY());
            entityPosition.setWidth(this.position.getWidth());
            entityPosition.setHeight(this.position.getHeight());
        }

        Node.NodeUIMetadata entityUIMetadata = null;
        if (this.uiMetadata != null) {
            entityUIMetadata = new Node.NodeUIMetadata();
            entityUIMetadata.setIcon(this.uiMetadata.getIcon());
            entityUIMetadata.setColor(this.uiMetadata.getColor());
            entityUIMetadata.setCollapsed(this.uiMetadata.getCollapsed());
            entityUIMetadata.setLayer(this.uiMetadata.getLayer());
        }

        return Node.builder()
            .id(this.id)
            .nodeId(this.nodeId)
            .name(this.name)
            .description(this.description)
            .nodeType(this.nodeType)
            .nodeDescriptorVersion(this.nodeDescriptorVersion)
            .config(this.config)
            .inputs(this.inputs)
            .outputs(this.outputs)
            .properties(this.properties)
            .position(entityPosition)
            .uiMetadata(entityUIMetadata)
            .status(this.status != null ? this.status : Node.NodeStatus.ACTIVE)
            .build();
    }
}
```

**EdgeDTO.java**

```java
package tech.kayys.wayang.designer.domain.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import tech.kayys.wayang.designer.domain.model.Edge;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

/**
 * Data Transfer Object for Edge
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class EdgeDTO {

    private UUID id;

    @NotBlank(message = "Edge ID is required")
    private String edgeId;

    @NotBlank(message = "Source node ID is required")
    private String sourceNodeId;

    @NotBlank(message = "Source port is required")
    private String sourcePort;

    @NotBlank(message = "Target node ID is required")
    private String targetNodeId;

    @NotBlank(message = "Target port is required")
    private String targetPort;

    private Edge.EdgeType edgeType;
    private String condition;
    private String transformation;
    private Map<String, Object> properties;
    private UIMetadataDTO uiMetadata;
    private Edge.EdgeStatus status;
    private Instant createdAt;
    private Instant updatedAt;
    private Long version;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class UIMetadataDTO {
        private String style;
        private String color;
        private String label;
        private Boolean animated;
    }

    public static EdgeDTO from(Edge edge) {
        if (edge == null) return null;

        UIMetadataDTO uiMetadataDTO = null;
        if (edge.getUiMetadata() != null) {
            uiMetadataDTO = UIMetadataDTO.builder()
                .style(edge.getUiMetadata().getStyle())
                .color(edge.getUiMetadata().getColor())
                .label(edge.getUiMetadata().getLabel())
                .animated(edge.getUiMetadata().getAnimated())
                .build();
        }

        return EdgeDTO.builder()
            .id(edge.getId())
            .edgeId(edge.getEdgeId())
            .sourceNodeId(edge.getSourceNodeId())
            .sourcePort(edge.getSourcePort())
            .targetNodeId(edge.getTargetNodeId())
            .targetPort(edge.getTargetPort())
            .edgeType(edge.getEdgeType())
            .condition(edge.getCondition())
            .transformation(edge.getTransformation())
            .properties(edge.getProperties())
            .uiMetadata(uiMetadataDTO)
            .status(edge.getStatus())
            .createdAt(edge.getCreatedAt())
            .updatedAt(edge.getUpdatedAt())
            .version(edge.getVersion())
            .build();
    }

    public Edge toEntity() {
        Edge.EdgeUIMetadata entityUIMetadata = null;
        if (this.uiMetadata != null) {
            entityUIMetadata = new Edge.EdgeUIMetadata();
            entityUIMetadata.setStyle(this.uiMetadata.getStyle());
            entityUIMetadata.setColor(this.uiMetadata.getColor());
            entityUIMetadata.setLabel(this.uiMetadata.getLabel());
            entityUIMetadata.setAnimated(this.uiMetadata.getAnimated());
        }

        return Edge.builder()
            .id(this.id)
            .edgeId(this.edgeId)
            .sourceNodeId(this.sourceNodeId)
            .sourcePort(this.sourcePort)
            .targetNodeId(this.targetNodeId)
            .targetPort(this.targetPort)
            .edgeType(this.edgeType != null ? this.edgeType : Edge.EdgeType.DATA)
            .condition(this.condition)
            .transformation(this.transformation)
            .properties(this.properties)
            .uiMetadata(entityUIMetadata)
            .status(this.status != null ? this.status : Edge.EdgeStatus.ACTIVE)
            .build();
    }
}
```

**LayoutDTO.java**

```java
package tech.kayys.wayang.designer.domain.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import tech.kayys.wayang.designer.domain.model.Layout;

import java.util.Map;
import java.util.UUID;

/**
 * Data Transfer Object for Layout
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class LayoutDTO {

    private UUID id;
    private ViewportDTO viewport;
    private Boolean minimapEnabled;
    private Boolean gridEnabled;
    private Boolean snapToGrid;
    private Map<String, Object> settings;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class ViewportDTO {
        private Double x;
        private Double y;
        private Double zoom;
    }

    public static LayoutDTO from(Layout layout) {
        if (layout == null) return null;

        ViewportDTO viewportDTO = null;
        if (layout.getViewport() != null) {
            viewportDTO = ViewportDTO.builder()
                .x(layout.getViewport().getX())
                .y(layout.getViewport().getY())
                .zoom(layout.getViewport().getZoom())
                .build();
        }

        return LayoutDTO.builder()
            .id(layout.getId())
            .viewport(viewportDTO)
            .minimapEnabled(layout.getMinimapEnabled())
            .gridEnabled(layout.getGridEnabled())
            .snapToGrid(layout.getSnapToGrid())
            .settings(layout.getSettings())
            .build();
    }

    public Layout toEntity() {
        Layout.Viewport entityViewport = null;
        if (this.viewport != null) {
            entityViewport = new Layout.Viewport();
            entityViewport.setX(this.viewport.getX());
            entityViewport.setY(this.viewport.getY());
            entityViewport.setZoom(this.viewport.getZoom());
        }

        return Layout.builder()
            .id(this.id)
            .viewport(entityViewport)
            .minimapEnabled(this.minimapEnabled)
            .gridEnabled(this.gridEnabled)
            .snapToGrid(this.snapToGrid)
            .settings(this.settings)
            .build();
    }
}
```

Continue with Part 3?


### 5. Repositories

**WorkspaceRepository.java**

```java
package tech.kayys.wayang.designer.domain.repository;

import io.quarkus.hibernate.orm.panache.PanacheRepositoryBase;
import io.quarkus.panache.common.Parameters;
import jakarta.enterprise.context.ApplicationScoped;
import tech.kayys.wayang.designer.domain.model.Workspace;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository for Workspace entities
 * 
 * Provides data access methods with proper multi-tenancy support
 * and optimized queries for common operations.
 */
@ApplicationScoped
public class WorkspaceRepository implements PanacheRepositoryBase<Workspace, UUID> {

    /**
     * Find workspace by ID with tenant validation
     */
    public Optional<Workspace> findByIdAndTenant(UUID id, UUID tenantId) {
        return find("id = :id and tenantId = :tenantId and status != :deleted",
            Parameters.with("id", id)
                .and("tenantId", tenantId)
                .and("deleted", Workspace.WorkspaceStatus.DELETED))
            .firstResultOptional();
    }

    /**
     * List all workspaces for a tenant
     */
    public List<Workspace> findByTenant(UUID tenantId, int page, int size) {
        return find("tenantId = :tenantId and status != :deleted order by updatedAt desc",
            Parameters.with("tenantId", tenantId)
                .and("deleted", Workspace.WorkspaceStatus.DELETED))
            .page(page, size)
            .list();
    }

    /**
     * Find workspaces by owner
     */
    public List<Workspace> findByOwner(UUID tenantId, String ownerId, int page, int size) {
        return find("tenantId = :tenantId and ownerId = :ownerId and status != :deleted order by updatedAt desc",
            Parameters.with("tenantId", tenantId)
                .and("ownerId", ownerId)
                .and("deleted", Workspace.WorkspaceStatus.DELETED))
            .page(page, size)
            .list();
    }

    /**
     * Search workspaces by name
     */
    public List<Workspace> searchByName(UUID tenantId, String namePattern, int page, int size) {
        return find("tenantId = :tenantId and lower(name) like :pattern and status != :deleted order by name",
            Parameters.with("tenantId", tenantId)
                .and("pattern", "%" + namePattern.toLowerCase() + "%")
                .and("deleted", Workspace.WorkspaceStatus.DELETED))
            .page(page, size)
            .list();
    }

    /**
     * Count workspaces by tenant
     */
    public long countByTenant(UUID tenantId) {
        return count("tenantId = :tenantId and status != :deleted",
            Parameters.with("tenantId", tenantId)
                .and("deleted", Workspace.WorkspaceStatus.DELETED));
    }

    /**
     * Check if workspace name exists for tenant
     */
    public boolean existsByNameAndTenant(String name, UUID tenantId) {
        return count("name = :name and tenantId = :tenantId and status != :deleted",
            Parameters.with("name", name)
                .and("tenantId", tenantId)
                .and("deleted", Workspace.WorkspaceStatus.DELETED)) > 0;
    }

    /**
     * Soft delete workspace
     */
    public void softDelete(UUID id, UUID tenantId) {
        update("status = :deleted, updatedAt = current_timestamp where id = :id and tenantId = :tenantId",
            Parameters.with("deleted", Workspace.WorkspaceStatus.DELETED)
                .and("id", id)
                .and("tenantId", tenantId));
    }

    /**
     * Find workspaces with workflow count
     */
    public List<Object[]> findWithWorkflowCount(UUID tenantId) {
        return getEntityManager()
            .createQuery(
                "SELECT w, COUNT(wf) FROM Workspace w LEFT JOIN w.workflows wf " +
                "WHERE w.tenantId = :tenantId AND w.status != :deleted " +
                "GROUP BY w ORDER BY w.updatedAt DESC",
                Object[].class)
            .setParameter("tenantId", tenantId)
            .setParameter("deleted", Workspace.WorkspaceStatus.DELETED)
            .getResultList();
    }
}
```

**WorkflowRepository.java**

```java
package tech.kayys.wayang.designer.domain.repository;

import io.quarkus.hibernate.orm.panache.PanacheRepositoryBase;
import io.quarkus.panache.common.Parameters;
import jakarta.enterprise.context.ApplicationScoped;
import tech.kayys.wayang.designer.domain.model.Workflow;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository for Workflow entities
 */
@ApplicationScoped
public class WorkflowRepository implements PanacheRepositoryBase<Workflow, UUID> {

    /**
     * Find workflow by ID with tenant validation
     */
    public Optional<Workflow> findByIdAndTenant(UUID id, UUID tenantId) {
        return find("id = :id and tenantId = :tenantId and status != :deleted",
            Parameters.with("id", id)
                .and("tenantId", tenantId)
                .and("deleted", Workflow.WorkflowStatus.DELETED))
            .firstResultOptional();
    }

    /**
     * Find workflow with nodes and edges (eager loading)
     */
    public Optional<Workflow> findByIdWithNodes(UUID id, UUID tenantId) {
        return find(
            "SELECT DISTINCT w FROM Workflow w " +
            "LEFT JOIN FETCH w.nodes " +
            "LEFT JOIN FETCH w.edges " +
            "LEFT JOIN FETCH w.layout " +
            "WHERE w.id = :id AND w.tenantId = :tenantId AND w.status != :deleted",
            Parameters.with("id", id)
                .and("tenantId", tenantId)
                .and("deleted", Workflow.WorkflowStatus.DELETED))
            .firstResultOptional();
    }

    /**
     * List workflows by workspace
     */
    public List<Workflow> findByWorkspace(UUID workspaceId, UUID tenantId, int page, int size) {
        return find("workspace.id = :workspaceId and tenantId = :tenantId and status != :deleted order by updatedAt desc",
            Parameters.with("workspaceId", workspaceId)
                .and("tenantId", tenantId)
                .and("deleted", Workflow.WorkflowStatus.DELETED))
            .page(page, size)
            .list();
    }

    /**
     * List workflows by status
     */
    public List<Workflow> findByStatus(UUID tenantId, Workflow.WorkflowStatus status, int page, int size) {
        return find("tenantId = :tenantId and status = :status order by updatedAt desc",
            Parameters.with("tenantId", tenantId)
                .and("status", status))
            .page(page, size)
            .list();
    }

    /**
     * Search workflows by name
     */
    public List<Workflow> searchByName(UUID tenantId, String namePattern, int page, int size) {
        return find("tenantId = :tenantId and lower(name) like :pattern and status != :deleted order by name",
            Parameters.with("tenantId", tenantId)
                .and("pattern", "%" + namePattern.toLowerCase() + "%")
                .and("deleted", Workflow.WorkflowStatus.DELETED))
            .page(page, size)
            .list();
    }

    /**
     * Find published workflows
     */
    public List<Workflow> findPublished(UUID tenantId, int page, int size) {
        return find("tenantId = :tenantId and status = :published order by publishedAt desc",
            Parameters.with("tenantId", tenantId)
                .and("published", Workflow.WorkflowStatus.PUBLISHED))
            .page(page, size)
            .list();
    }

    /**
     * Count workflows by workspace
     */
    public long countByWorkspace(UUID workspaceId, UUID tenantId) {
        return count("workspace.id = :workspaceId and tenantId = :tenantId and status != :deleted",
            Parameters.with("workspaceId", workspaceId)
                .and("tenantId", tenantId)
                .and("deleted", Workflow.WorkflowStatus.DELETED));
    }

    /**
     * Count workflows by tenant
     */
    public long countByTenant(UUID tenantId) {
        return count("tenantId = :tenantId and status != :deleted",
            Parameters.with("tenantId", tenantId)
                .and("deleted", Workflow.WorkflowStatus.DELETED));
    }

    /**
     * Check if workflow name exists in workspace
     */
    public boolean existsByNameInWorkspace(String name, UUID workspaceId, UUID tenantId) {
        return count("name = :name and workspace.id = :workspaceId and tenantId = :tenantId and status != :deleted",
            Parameters.with("name", name)
                .and("workspaceId", workspaceId)
                .and("tenantId", tenantId)
                .and("deleted", Workflow.WorkflowStatus.DELETED)) > 0;
    }

    /**
     * Soft delete workflow
     */
    public void softDelete(UUID id, UUID tenantId) {
        update("status = :deleted, updatedAt = current_timestamp where id = :id and tenantId = :tenantId",
            Parameters.with("deleted", Workflow.WorkflowStatus.DELETED)
                .and("id", id)
                .and("tenantId", tenantId));
    }

    /**
     * Find workflows requiring validation
     */
    public List<Workflow> findRequiringValidation(UUID tenantId, int limit) {
        return find("tenantId = :tenantId and status = :draft " +
            "and (validationState is null or validationState.isValid is null) " +
            "order by updatedAt asc",
            Parameters.with("tenantId", tenantId)
                .and("draft", Workflow.WorkflowStatus.DRAFT))
            .page(0, limit)
            .list();
    }
}
```

**NodeRepository.java**

```java
package tech.kayys.wayang.designer.domain.repository;

import io.quarkus.hibernate.orm.panache.PanacheRepositoryBase;
import io.quarkus.panache.common.Parameters;
import jakarta.enterprise.context.ApplicationScoped;
import tech.kayys.wayang.designer.domain.model.Node;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository for Node entities
 */
@ApplicationScoped
public class NodeRepository implements PanacheRepositoryBase<Node, UUID> {

    /**
     * Find node by ID with tenant validation
     */
    public Optional<Node> findByIdAndTenant(UUID id, UUID tenantId) {
        return find("id = :id and tenantId = :tenantId",
            Parameters.with("id", id)
                .and("tenantId", tenantId))
            .firstResultOptional();
    }

    /**
     * Find node by nodeId (user-friendly ID) in workflow
     */
    public Optional<Node> findByNodeIdInWorkflow(String nodeId, UUID workflowId, UUID tenantId) {
        return find("nodeId = :nodeId and workflow.id = :workflowId and tenantId = :tenantId",
            Parameters.with("nodeId", nodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .firstResultOptional();
    }

    /**
     * List all nodes in a workflow
     */
    public List<Node> findByWorkflow(UUID workflowId, UUID tenantId) {
        return find("workflow.id = :workflowId and tenantId = :tenantId order by createdAt",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }

    /**
     * Find nodes by type in workflow
     */
    public List<Node> findByTypeInWorkflow(String nodeType, UUID workflowId, UUID tenantId) {
        return find("nodeType = :nodeType and workflow.id = :workflowId and tenantId = :tenantId",
            Parameters.with("nodeType", nodeType)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }

    /**
     * Count nodes in workflow
     */
    public long countByWorkflow(UUID workflowId, UUID tenantId) {
        return count("workflow.id = :workflowId and tenantId = :tenantId",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId));
    }

    /**
     * Check if nodeId exists in workflow
     */
    public boolean existsByNodeIdInWorkflow(String nodeId, UUID workflowId, UUID tenantId) {
        return count("nodeId = :nodeId and workflow.id = :workflowId and tenantId = :tenantId",
            Parameters.with("nodeId", nodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId)) > 0;
    }

    /**
     * Delete all nodes in workflow
     */
    public void deleteByWorkflow(UUID workflowId, UUID tenantId) {
        delete("workflow.id = :workflowId and tenantId = :tenantId",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId));
    }

    /**
     * Find nodes by status in workflow
     */
    public List<Node> findByStatusInWorkflow(Node.NodeStatus status, UUID workflowId, UUID tenantId) {
        return find("status = :status and workflow.id = :workflowId and tenantId = :tenantId",
            Parameters.with("status", status)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }
}
```

**EdgeRepository.java**

```java
package tech.kayys.wayang.designer.domain.repository;

import io.quarkus.hibernate.orm.panache.PanacheRepositoryBase;
import io.quarkus.panache.common.Parameters;
import jakarta.enterprise.context.ApplicationScoped;
import tech.kayys.wayang.designer.domain.model.Edge;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository for Edge entities
 */
@ApplicationScoped
public class EdgeRepository implements PanacheRepositoryBase<Edge, UUID> {

    /**
     * Find edge by ID with tenant validation
     */
    public Optional<Edge> findByIdAndTenant(UUID id, UUID tenantId) {
        return find("id = :id and workflow.tenantId = :tenantId",
            Parameters.with("id", id)
                .and("tenantId", tenantId))
            .firstResultOptional();
    }

    /**
     * Find edge by edgeId in workflow
     */
    public Optional<Edge> findByEdgeIdInWorkflow(String edgeId, UUID workflowId, UUID tenantId) {
        return find("edgeId = :edgeId and workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("edgeId", edgeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .firstResultOptional();
    }

    /**
     * List all edges in workflow
     */
    public List<Edge> findByWorkflow(UUID workflowId, UUID tenantId) {
        return find("workflow.id = :workflowId and workflow.tenantId = :tenantId order by createdAt",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }

    /**
     * Find edges connected to a node (source or target)
     */
    public List<Edge> findByNode(String nodeId, UUID workflowId, UUID tenantId) {
        return find("(sourceNodeId = :nodeId or targetNodeId = :nodeId) " +
            "and workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("nodeId", nodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }

    /**
     * Find outgoing edges from a node
     */
    public List<Edge> findBySourceNode(String sourceNodeId, UUID workflowId, UUID tenantId) {
        return find("sourceNodeId = :sourceNodeId and workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("sourceNodeId", sourceNodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }

    /**
     * Find incoming edges to a node
     */
    public List<Edge> findByTargetNode(String targetNodeId, UUID workflowId, UUID tenantId) {
        return find("targetNodeId = :targetNodeId and workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("targetNodeId", targetNodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();
    }

    /**
     * Check if edge exists between two nodes
     */
    public boolean existsBetweenNodes(String sourceNodeId, String targetNodeId, UUID workflowId, UUID tenantId) {
        return count("sourceNodeId = :sourceNodeId and targetNodeId = :targetNodeId " +
            "and workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("sourceNodeId", sourceNodeId)
                .and("targetNodeId", targetNodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId)) > 0;
    }

    /**
     * Count edges in workflow
     */
    public long countByWorkflow(UUID workflowId, UUID tenantId) {
        return count("workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId));
    }

    /**
     * Delete all edges in workflow
     */
    public void deleteByWorkflow(UUID workflowId, UUID tenantId) {
        delete("workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId));
    }

    /**
     * Delete edges connected to a node
     */
    public void deleteByNode(String nodeId, UUID workflowId, UUID tenantId) {
        delete("(sourceNodeId = :nodeId or targetNodeId = :nodeId) " +
            "and workflow.id = :workflowId and workflow.tenantId = :tenantId",
            Parameters.with("nodeId", nodeId)
                .and("workflowId", workflowId)
                .and("tenantId", tenantId));
    }
}
```

**DraftRepository.java**

```java
package tech.kayys.wayang.designer.domain.repository;

import io.quarkus.hibernate.orm.panache.PanacheRepositoryBase;
import io.quarkus.panache.common.Parameters;
import jakarta.enterprise.context.ApplicationScoped;
import tech.kayys.wayang.designer.domain.model.Draft;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository for Draft entities
 */
@ApplicationScoped
public class DraftRepository implements PanacheRepositoryBase<Draft, UUID> {

    /**
     * Find latest draft for workflow
     */
    public Optional<Draft> findLatestByWorkflow(UUID workflowId, UUID tenantId) {
        return find("workflowId = :workflowId and tenantId = :tenantId order by createdAt desc",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId))
            .firstResultOptional();
    }

    /**
     * Find all drafts for workflow
     */
    public List<Draft> findByWorkflow(UUID workflowId, UUID tenantId, int limit) {
        return find("workflowId = :workflowId and tenantId = :tenantId order by createdAt desc",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId))
            .page(0, limit)
            .list();
    }

    /**
     * Count drafts for workflow
     */
    public long countByWorkflow(UUID workflowId, UUID tenantId) {
        return count("workflowId = :workflowId and tenantId = :tenantId",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId));
    }

    /**
     * Delete oldest drafts for workflow, keeping specified count
     */
    public void deleteOldest(UUID workflowId, UUID tenantId, int keepCount) {
        List<Draft> drafts = find("workflowId = :workflowId and tenantId = :tenantId order by createdAt desc",
            Parameters.with("workflowId", workflowId)
                .and("tenantId", tenantId))
            .list();

        if (drafts.size() > keepCount) {
            List<UUID> idsToDelete = drafts.subList(keepCount, drafts.size())
                .stream()
                .map(Draft::getId)
                .toList();

            delete("id in (?1)", idsToDelete);
        }
    }

    /**
     * Delete expired drafts
     */
    public long deleteExpired() {
        return delete("expiresAt < :now", Parameters.with("now", Instant.now()));
    }

    /**
     * Find drafts by user
     */
    public List<Draft> findByUser(String userId, UUID tenantId, int page, int size) {
        return find("createdBy = :userId and tenantId = :tenantId order by createdAt desc",
            Parameters.with("userId", userId)
                .and("tenantId", tenantId))
            .page(page, size)
            .list();
    }
}
```

Continue with Part 4?


### 6. Service Layer

**WorkspaceService.java**

```java
package tech.kayys.wayang.designer.service;

import io.quarkus.panache.common.Page;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import tech.kayys.wayang.designer.audit.AuditLogger;
import tech.kayys.wayang.designer.domain.dto.WorkspaceDTO;
import tech.kayys.wayang.designer.domain.model.Workspace;
import tech.kayys.wayang.designer.domain.repository.WorkspaceRepository;
import tech.kayys.wayang.designer.domain.repository.WorkflowRepository;
import tech.kayys.wayang.designer.error.DesignerException;
import tech.kayys.wayang.designer.error.ValidationException;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
 * Service for managing workspaces
 * 
 * Handles business logic for workspace CRUD operations, validation,
 * and integration with audit logging. Enforces tenant isolation and
 * workspace limits.
 */
@ApplicationScoped
@Slf4j
public class WorkspaceService {

    @Inject
    WorkspaceRepository workspaceRepository;

    @Inject
    WorkflowRepository workflowRepository;

    @Inject
    AuditLogger auditLogger;

    @ConfigProperty(name = "wayang.designer.workspace.max-per-tenant", defaultValue = "100")
    int maxWorkspacesPerTenant;

    /**
     * Create a new workspace
     */
    @Transactional
    public WorkspaceDTO createWorkspace(WorkspaceDTO dto, UUID tenantId, String userId) {
        log.debug("Creating workspace: {} for tenant: {}", dto.getName(), tenantId);

        // Validate tenant limits
        long currentCount = workspaceRepository.countByTenant(tenantId);
        if (currentCount >= maxWorkspacesPerTenant) {
            throw new ValidationException(
                "WORKSPACE_LIMIT_EXCEEDED",
                "Maximum number of workspaces (" + maxWorkspacesPerTenant + ") exceeded for tenant"
            );
        }

        // Check name uniqueness
        if (workspaceRepository.existsByNameAndTenant(dto.getName(), tenantId)) {
            throw new ValidationException(
                "WORKSPACE_NAME_EXISTS",
                "Workspace with name '" + dto.getName() + "' already exists"
            );
        }

        // Create entity
        Workspace workspace = dto.toEntity();
        workspace.setTenantId(tenantId);
        workspace.setOwnerId(userId);
        workspace.setCreatedBy(userId);
        workspace.setStatus(Workspace.WorkspaceStatus.ACTIVE);

        // Initialize metadata
        if (workspace.getMetadata() == null) {
            workspace.setMetadata(new Workspace.WorkspaceMetadata());
        }
        workspace.getMetadata().setWorkflowCount(0);
        workspace.getMetadata().setLastAccessedAt(Instant.now());

        workspaceRepository.persist(workspace);

        // Audit log
        auditLogger.log(
            "WORKSPACE_CREATED",
            tenantId,
            userId,
            "workspace",
            workspace.getId().toString(),
            "Created workspace: " + workspace.getName()
        );

        log.info("Workspace created: {} (ID: {})", workspace.getName(), workspace.getId());
        return WorkspaceDTO.from(workspace);
    }

    /**
     * Get workspace by ID
     */
    public WorkspaceDTO getWorkspace(UUID id, UUID tenantId) {
        log.debug("Getting workspace: {} for tenant: {}", id, tenantId);

        Workspace workspace = workspaceRepository.findByIdAndTenant(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKSPACE_NOT_FOUND",
                "Workspace not found: " + id
            ));

        // Update last accessed
        updateLastAccessed(workspace);

        return WorkspaceDTO.from(workspace);
    }

    /**
     * List workspaces for tenant
     */
    public List<WorkspaceDTO> listWorkspaces(UUID tenantId, int page, int size) {
        log.debug("Listing workspaces for tenant: {} (page: {}, size: {})", tenantId, page, size);

        List<Workspace> workspaces = workspaceRepository.findByTenant(tenantId, page, size);
        return workspaces.stream()
            .map(WorkspaceDTO::from)
            .toList();
    }

    /**
     * List workspaces by owner
     */
    public List<WorkspaceDTO> listWorkspacesByOwner(UUID tenantId, String ownerId, int page, int size) {
        log.debug("Listing workspaces for owner: {} in tenant: {}", ownerId, tenantId);

        List<Workspace> workspaces = workspaceRepository.findByOwner(tenantId, ownerId, page, size);
        return workspaces.stream()
            .map(WorkspaceDTO::from)
            .toList();
    }

    /**
     * Search workspaces by name
     */
    public List<WorkspaceDTO> searchWorkspaces(UUID tenantId, String query, int page, int size) {
        log.debug("Searching workspaces for tenant: {} with query: {}", tenantId, query);

        List<Workspace> workspaces = workspaceRepository.searchByName(tenantId, query, page, size);
        return workspaces.stream()
            .map(WorkspaceDTO::from)
            .toList();
    }

    /**
     * Update workspace
     */
    @Transactional
    public WorkspaceDTO updateWorkspace(UUID id, WorkspaceDTO dto, UUID tenantId, String userId) {
        log.debug("Updating workspace: {} for tenant: {}", id, tenantId);

        Workspace workspace = workspaceRepository.findByIdAndTenant(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKSPACE_NOT_FOUND",
                "Workspace not found: " + id
            ));

        // Check name uniqueness if changed
        if (!workspace.getName().equals(dto.getName()) &&
            workspaceRepository.existsByNameAndTenant(dto.getName(), tenantId)) {
            throw new ValidationException(
                "WORKSPACE_NAME_EXISTS",
                "Workspace with name '" + dto.getName() + "' already exists"
            );
        }

        // Update fields
        workspace.setName(dto.getName());
        workspace.setDescription(dto.getDescription());
        workspace.setTags(dto.getTags());
        workspace.setUpdatedBy(userId);

        // Update metadata if provided
        if (dto.getMetadata() != null) {
            if (workspace.getMetadata() == null) {
                workspace.setMetadata(new Workspace.WorkspaceMetadata());
            }
            if (dto.getMetadata().getIcon() != null) {
                workspace.getMetadata().setIcon(dto.getMetadata().getIcon());
            }
            if (dto.getMetadata().getColor() != null) {
                workspace.getMetadata().setColor(dto.getMetadata().getColor());
            }
            if (dto.getMetadata().getFavorite() != null) {
                workspace.getMetadata().setFavorite(dto.getMetadata().getFavorite());
            }
        }

        workspaceRepository.persist(workspace);

        // Audit log
        auditLogger.log(
            "WORKSPACE_UPDATED",
            tenantId,
            userId,
            "workspace",
            workspace.getId().toString(),
            "Updated workspace: " + workspace.getName()
        );

        log.info("Workspace updated: {} (ID: {})", workspace.getName(), workspace.getId());
        return WorkspaceDTO.from(workspace);
    }

    /**
     * Delete workspace (soft delete)
     */
    @Transactional
    public void deleteWorkspace(UUID id, UUID tenantId, String userId) {
        log.debug("Deleting workspace: {} for tenant: {}", id, tenantId);

        Workspace workspace = workspaceRepository.findByIdAndTenant(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKSPACE_NOT_FOUND",
                "Workspace not found: " + id
            ));

        // Check if workspace has workflows
        long workflowCount = workflowRepository.countByWorkspace(id, tenantId);
        if (workflowCount > 0) {
            throw new ValidationException(
                "WORKSPACE_HAS_WORKFLOWS",
                "Cannot delete workspace with existing workflows. Please delete workflows first."
            );
        }

        // Soft delete
        workspace.setStatus(Workspace.WorkspaceStatus.DELETED);
        workspace.setUpdatedBy(userId);
        workspaceRepository.persist(workspace);

        // Audit log
        auditLogger.log(
            "WORKSPACE_DELETED",
            tenantId,
            userId,
            "workspace",
            workspace.getId().toString(),
            "Deleted workspace: " + workspace.getName()
        );

        log.info("Workspace deleted: {} (ID: {})", workspace.getName(), workspace.getId());
    }

    /**
     * Archive workspace
     */
    @Transactional
    public WorkspaceDTO archiveWorkspace(UUID id, UUID tenantId, String userId) {
        log.debug("Archiving workspace: {} for tenant: {}", id, tenantId);

        Workspace workspace = workspaceRepository.findByIdAndTenant(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKSPACE_NOT_FOUND",
                "Workspace not found: " + id
            ));

        workspace.setStatus(Workspace.WorkspaceStatus.ARCHIVED);
        workspace.setUpdatedBy(userId);
        workspaceRepository.persist(workspace);

        // Audit log
        auditLogger.log(
            "WORKSPACE_ARCHIVED",
            tenantId,
            userId,
            "workspace",
            workspace.getId().toString(),
            "Archived workspace: " + workspace.getName()
        );

        log.info("Workspace archived: {} (ID: {})", workspace.getName(), workspace.getId());
        return WorkspaceDTO.from(workspace);
    }

    /**
     * Get workspace statistics
     */
    public WorkspaceStatistics getStatistics(UUID tenantId) {
        long totalCount = workspaceRepository.countByTenant(tenantId);
        long activeCount = workspaceRepository.count(
            "tenantId = ?1 and status = ?2",
            tenantId,
            Workspace.WorkspaceStatus.ACTIVE
        );
        long archivedCount = workspaceRepository.count(
            "tenantId = ?1 and status = ?2",
            tenantId,
            Workspace.WorkspaceStatus.ARCHIVED
        );

        return WorkspaceStatistics.builder()
            .total(totalCount)
            .active(activeCount)
            .archived(archivedCount)
            .build();
    }

    @Transactional
    private void updateLastAccessed(Workspace workspace) {
        if (workspace.getMetadata() == null) {
            workspace.setMetadata(new Workspace.WorkspaceMetadata());
        }
        workspace.getMetadata().setLastAccessedAt(Instant.now());
    }

    @lombok.Data
    @lombok.Builder
    public static class WorkspaceStatistics {
        private long total;
        private long active;
        private long archived;
    }
}
```

**WorkflowService.java**

```java
package tech.kayys.wayang.designer.service;

import io.quarkus.cache.CacheResult;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import tech.kayys.wayang.designer.audit.AuditLogger;
import tech.kayys.wayang.designer.client.SchemaRegistryClient;
import tech.kayys.wayang.designer.client.VersionServiceClient;
import tech.kayys.wayang.designer.domain.dto.WorkflowDTO;
import tech.kayys.wayang.designer.domain.model.*;
import tech.kayys.wayang.designer.domain.repository.*;
import tech.kayys.wayang.designer.error.DesignerException;
import tech.kayys.wayang.designer.error.ValidationException;
import tech.kayys.wayang.designer.validation.ValidationService;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
 * Service for managing workflows
 * 
 * Handles workflow lifecycle including creation, updates, validation,
 * publishing, and deletion. Integrates with validation, versioning,
 * and schema services.
 */
@ApplicationScoped
@Slf4j
public class WorkflowService {

    @Inject
    WorkflowRepository workflowRepository;

    @Inject
    WorkspaceRepository workspaceRepository;

    @Inject
    NodeRepository nodeRepository;

    @Inject
    EdgeRepository edgeRepository;

    @Inject
    ValidationService validationService;

    @Inject
    VersionServiceClient versionService;

    @Inject
    AuditLogger auditLogger;

    @ConfigProperty(name = "wayang.designer.workflow.max-nodes", defaultValue = "1000")
    int maxNodesPerWorkflow;

    @ConfigProperty(name = "wayang.designer.workflow.max-edges", defaultValue = "2000")
    int maxEdgesPerWorkflow;

    /**
     * Create a new workflow
     */
    @Transactional
    public WorkflowDTO createWorkflow(WorkflowDTO dto, UUID tenantId, String userId) {
        log.debug("Creating workflow: {} for tenant: {}", dto.getName(), tenantId);

        // Validate workspace exists
        Workspace workspace = workspaceRepository.findByIdAndTenant(dto.getWorkspaceId(), tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKSPACE_NOT_FOUND",
                "Workspace not found: " + dto.getWorkspaceId()
            ));

        // Check name uniqueness in workspace
        if (workflowRepository.existsByNameInWorkspace(dto.getName(), dto.getWorkspaceId(), tenantId)) {
            throw new ValidationException(
                "WORKFLOW_NAME_EXISTS",
                "Workflow with name '" + dto.getName() + "' already exists in workspace"
            );
        }

        // Create workflow entity
        Workflow workflow = Workflow.builder()
            .name(dto.getName())
            .description(dto.getDescription())
            .workspace(workspace)
            .tenantId(tenantId)
            .status(Workflow.WorkflowStatus.DRAFT)
            .tags(dto.getTags())
            .createdBy(userId)
            .build();

        // Initialize configuration
        if (dto.getConfiguration() != null) {
            workflow.setConfiguration(convertConfiguration(dto.getConfiguration()));
        }

        // Create default layout
        Layout layout = Layout.builder()
            .workflow(workflow)
            .viewport(new Layout.Viewport(0.0, 0.0, 1.0))
            .minimapEnabled(true)
            .gridEnabled(true)
            .snapToGrid(false)
            .build();
        workflow.setLayout(layout);

        workflowRepository.persist(workflow);

        // Audit log
        auditLogger.log(
            "WORKFLOW_CREATED",
            tenantId,
            userId,
            "workflow",
            workflow.getId().toString(),
            "Created workflow: " + workflow.getName()
        );

        log.info("Workflow created: {} (ID: {})", workflow.getName(), workflow.getId());
        return WorkflowDTO.from(workflow, false);
    }

    /**
     * Get workflow by ID
     */
    @CacheResult(cacheName = "workflow-cache")
    public WorkflowDTO getWorkflow(UUID id, UUID tenantId, boolean includeNodes) {
        log.debug("Getting workflow: {} for tenant: {} (includeNodes: {})", id, tenantId, includeNodes);

        Workflow workflow;
        if (includeNodes) {
            workflow = workflowRepository.findByIdWithNodes(id, tenantId)
                .orElseThrow(() -> new DesignerException(
                    "WORKFLOW_NOT_FOUND",
                    "Workflow not found: " + id
                ));
        } else {
            workflow = workflowRepository.findByIdAndTenant(id, tenantId)
                .orElseThrow(() -> new DesignerException(
                    "WORKFLOW_NOT_FOUND",
                    "Workflow not found: " + id
                ));
        }

        return WorkflowDTO.from(workflow, includeNodes);
    }

    /**
     * List workflows in workspace
     */
    public List<WorkflowDTO> listWorkflows(UUID workspaceId, UUID tenantId, int page, int size) {
        log.debug("Listing workflows in workspace: {} for tenant: {}", workspaceId, tenantId);

        List<Workflow> workflows = workflowRepository.findByWorkspace(workspaceId, tenantId, page, size);
        return workflows.stream()
            .map(w -> WorkflowDTO.from(w, false))
            .toList();
    }

    /**
     * Search workflows by name
     */
    public List<WorkflowDTO> searchWorkflows(UUID tenantId, String query, int page, int size) {
        log.debug("Searching workflows for tenant: {} with query: {}", tenantId, query);

        List<Workflow> workflows = workflowRepository.searchByName(tenantId, query, page, size);
        return workflows.stream()
            .map(w -> WorkflowDTO.from(w, false))
            .toList();
    }

    /**
     * Update workflow
     */
    @Transactional
    public WorkflowDTO updateWorkflow(UUID id, WorkflowDTO dto, UUID tenantId, String userId) {
        log.debug("Updating workflow: {} for tenant: {}", id, tenantId);

        Workflow workflow = workflowRepository.findByIdAndTenant(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKFLOW_NOT_FOUND",
                "Workflow not found: " + id
            ));

        // Cannot update published workflows
        if (workflow.getStatus() == Workflow.WorkflowStatus.PUBLISHED) {
            throw new ValidationException(
                "WORKFLOW_PUBLISHED",
                "Cannot update published workflow. Create a new version instead."
            );
        }

        // Check name uniqueness if changed
        if (!workflow.getName().equals(dto.getName()) &&
            workflowRepository.existsByNameInWorkspace(
                dto.getName(),
                workflow.getWorkspace().getId(),
                tenantId
            )) {
            throw new ValidationException(
                "WORKFLOW_NAME_EXISTS",
                "Workflow with name '" + dto.getName() + "' already exists in workspace"
            );
        }

        // Update fields
        workflow.setName(dto.getName());
        workflow.setDescription(dto.getDescription());
        workflow.setTags(dto.getTags());
        workflow.setUpdatedBy(userId);

        // Update configuration
        if (dto.getConfiguration() != null) {
            workflow.setConfiguration(convertConfiguration(dto.getConfiguration()));
        }

        // Reset validation state on update
        workflow.setValidationState(null);
        workflow.setStatus(Workflow.WorkflowStatus.DRAFT);

        workflowRepository.persist(workflow);

        // Audit log
        auditLogger.log(
            "WORKFLOW_UPDATED",
            tenantId,
            userId,
            "workflow",
            workflow.getId().toString(),
            "Updated workflow: " + workflow.getName()
        );

        log.info("Workflow updated: {} (ID: {})", workflow.getName(), workflow.getId());
        return WorkflowDTO.from(workflow, false);
    }

    /**
     * Delete workflow (soft delete)
     */
    @Transactional
    public void deleteWorkflow(UUID id, UUID tenantId, String userId) {
        log.debug("Deleting workflow: {} for tenant: {}", id, tenantId);

        Workflow workflow = workflowRepository.findByIdAndTenant(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKFLOW_NOT_FOUND",
                "Workflow not found: " + id
            ));

        // Soft delete
        workflow.setStatus(Workflow.WorkflowStatus.DELETED);
        workflow.setUpdatedBy(userId);
        workflowRepository.persist(workflow);

        // Audit log
        auditLogger.log(
            "WORKFLOW_DELETED",
            tenantId,
            userId,
            "workflow",
            workflow.getId().toString(),
            "Deleted workflow: " + workflow.getName()
        );

        log.info("Workflow deleted: {} (ID: {})", workflow.getName(), workflow.getId());
    }

    /**
     * Validate workflow
     */
    @Transactional
    public WorkflowDTO validateWorkflow(UUID id, UUID tenantId, String userId) {
        log.debug("Validating workflow: {} for tenant: {}", id, tenantId);

        Workflow workflow = workflowRepository.findByIdWithNodes(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKFLOW_NOT_FOUND",
                "Workflow not found: " + id
            ));

        // Update status
        workflow.setStatus(Workflow.WorkflowStatus.VALIDATING);
        workflowRepository.persist(workflow);

        try {
            // Perform validation
            var validationResult = validationService.validateWorkflow(workflow);

            // Update validation state
            Workflow.ValidationState validationState = new Workflow.ValidationState();
            validationState.setIsValid(validationResult.isValid());
            validationState.setLastValidatedAt(Instant.now());
            validationState.setErrors(validationResult.getErrors().stream()
                .map(e -> new Workflow.ValidationError(
                    e.getCode(),
                    e.getMessage(),
                    e.getNodeId(),
                    e.getField(),
                    e.getSeverity()
                ))
                .toList());
            validationState.setWarnings(validationResult.getWarnings().stream()
                .map(w -> new Workflow.ValidationWarning(
                    w.getCode(),
                    w.getMessage(),
                    w.getNodeId()
                ))
                .toList());

            workflow.setValidationState(validationState);
            workflow.setStatus(validationResult.isValid() ?
                Workflow.WorkflowStatus.VALID :
                Workflow.WorkflowStatus.INVALID);

            workflowRepository.persist(workflow);

            // Audit log
            auditLogger.log(
                "WORKFLOW_VALIDATED",
                tenantId,
                userId,
                "workflow",
                workflow.getId().toString(),
                "Validated workflow: " + workflow.getName() +
                    " (valid: " + validationResult.isValid() + ")"
            );

            log.info("Workflow validated: {} (ID: {}, valid: {})",
                workflow.getName(), workflow.getId(), validationResult.isValid());

        } catch (Exception e) {
            log.error("Validation failed for workflow: " + id, e);
            workflow.setStatus(Workflow.WorkflowStatus.DRAFT);
            workflowRepository.persist(workflow);
            throw new DesignerException("VALIDATION_FAILED", "Workflow validation failed: " + e.getMessage());
        }

        return WorkflowDTO.from(workflow, true);
    }

    /**
     * Publish workflow (creates immutable version)
     */
    @Transactional
    public WorkflowDTO publishWorkflow(UUID id, UUID tenantId, String userId) {
        log.debug("Publishing workflow: {} for tenant: {}", id, tenantId);

        Workflow workflow = workflowRepository.findByIdWithNodes(id, tenantId)
            .orElseThrow(() -> new DesignerException(
                "WORKFLOW_NOT_FOUND",
                "Workflow not found: " + id
            ));

        // Must be valid before publishing
        if (workflow.getStatus() != Workflow.WorkflowStatus.VALID) {
            throw new ValidationException(
                "WORKFLOW_NOT_VALID",
                "Workflow must be validated before publishing"
            );
        }

        // Create version in version service
        String versionId = versionService.createVersion(workflow, userId);

        // Update workflow
        workflow.setStatus(Workflow.WorkflowStatus.PUBLISHED);
        workflow.setPublishedVersion(versionId);
        workflow.setPublishedAt(Instant.now());
        workflow.setUpdatedBy(userId);
        workflowRepository.persist(workflow);

        // Audit log
        auditLogger.log(
            "WORKFLOW_PUBLISHED",
            tenantId,
            userId,
            "workflow",
            workflow.getId().toString(),
            "Published workflow: " + workflow.getName() + " (version: " + versionId + ")"
        );

        log.info("Workflow published: {} (ID: {}, version: {})",
            workflow.getName(), workflow.getId(), versionId);

        return WorkflowDTO.from(workflow, true);
    }

    private Workflow.WorkflowConfiguration convertConfiguration(WorkflowDTO.ConfigurationDTO dto) {
        Workflow.WorkflowConfiguration config = new Workflow.WorkflowConfiguration();
        config.setMaxConcurrency(dto.getMaxConcurrency());
        config.setTimeout(dto.getTimeout());
        config.setRetryPolicy(dto.getRetryPolicy());
        config.setEnableCheckpoints(dto.getEnableCheckpoints());
        config.setEnableStreaming(dto.getEnableStreaming());
        return config;
    }
}
```

Continue with Part 5?

